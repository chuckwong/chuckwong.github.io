<!DOCTYPE html>




<html class="theme-next pisces" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,300italic,400,400italic,700,700italic|Bitter:300,300italic,400,400italic,700,700italic|Bitter:300,300italic,400,400italic,700,700italic|Menlo:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="junhaow, maodai">










<meta name="description" content="Source: LearnCpp.com by Alex ExceptionsBasic exception handlingThree keywords: throw, try, and catch. Throwing / raising exceptions 123456throw -1;throw ENUM_INVALID_INDEX;throw &quot;can not take square">
<meta property="og:type" content="website">
<meta property="og:title" content="Study Notes on LearnCpp (Part 6 - Exceptions, Smart Pointers)">
<meta property="og:url" content="http://www.junhaow.com/studynotes/cpp/learncpp/Study Notes on LearnCpp Part 6.html">
<meta property="og:site_name" content="B_L_OO_GGG">
<meta property="og:description" content="Source: LearnCpp.com by Alex ExceptionsBasic exception handlingThree keywords: throw, try, and catch. Throwing / raising exceptions 123456throw -1;throw ENUM_INVALID_INDEX;throw &quot;can not take square">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/2f2di.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/hsqjw.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/jdw9p.jpg">
<meta property="og:updated_time" content="2020-02-04T07:51:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Study Notes on LearnCpp (Part 6 - Exceptions, Smart Pointers)">
<meta name="twitter:description" content="Source: LearnCpp.com by Alex ExceptionsBasic exception handlingThree keywords: throw, try, and catch. Throwing / raising exceptions 123456throw -1;throw ENUM_INVALID_INDEX;throw &quot;can not take square">
<meta name="twitter:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/2f2di.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.junhaow.com/studynotes/cpp/learncpp/Study Notes on LearnCpp Part 6.html">





  <title>Study Notes on LearnCpp (Part 6 - Exceptions, Smart Pointers) | B_L_OO_GGG</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-146643833-1', 'auto');
  ga('send', 'pageview');
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->





</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">


  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">B_L_OO_GGG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Sumomo mo momo mo no uchi</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home


            

            

            

            

            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-inbox"></i> <br>
            
            Archives


            

            
              <span class="badge">50</span>
            

            

            

            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-studynotes">
          <a href="/studynotes/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-pencil"></i> <br>
            
            Study Notes


            

            

            
              <span class="badge">6</span>
            

            

            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-lc">
          <a href="/lc/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            LeetCode Book


            

            

            

            
              <span class="badge badge-lc">251 / âˆž</span>
            

            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-games">
          <a href="/games/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-gamepad"></i> <br>
            
            Games I've Played


            

            

            

            

            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-address-card"></i> <br>
            
            About Me


            

            

            

            

            
              <span class="badge-about">ðŸ‘‹</span>
            

          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

	<h1 class="post-title" itemprop="name headline">Study Notes on LearnCpp (Part 6 - Exceptions, Smart Pointers)</h1>



</header>

      
      
      
      <div class="post-body">
        
        
          <p><br></p>
<p>Source: <a href="https://www.learncpp.com/" target="_blank" rel="noopener">LearnCpp.com</a> by Alex</p>
<h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><h3 id="Basic-exception-handling"><a href="#Basic-exception-handling" class="headerlink" title="Basic exception handling"></a>Basic exception handling</h3><p>Three keywords: throw, try, and catch.</p>
<p><strong>Throwing / raising exceptions</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">throw</span> ENUM_INVALID_INDEX;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"can not take square root of negative number"</span>;</span><br><span class="line"><span class="comment">// throw a literal C-style root of negative number</span></span><br><span class="line"><span class="keyword">throw</span> dX;  <span class="comment">// throw a double variable that was previously defined</span></span><br><span class="line"><span class="keyword">throw</span> MyException(<span class="string">"Fatal Error"</span>); <span class="comment">// Throw an object of class MyException</span></span><br></pre></td></tr></table></figure>
<p>Once an exception has been caught by the try block and routed to a catch block for handling, the exception is considered handled, and execution will resume as normal after the catch block.</p>
<p>Catch parameters work just like function parameters, with the parameter being available within the subsequent catch block. Exceptions of fundamental types can be caught by value, but exceptions of non-fundamental types should be caught by const reference to avoid making an unnecessary copy.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Statements that may throw exceptions you want to handle go here</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="number">-1</span>;    <span class="comment">// here's a trivial example</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="comment">// Any exceptions of type int thrown within the above try block get sent here</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"We caught an int exception with value: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">double</span>) &#123;</span><br><span class="line">    <span class="comment">// no variable name since we don't use the exception itself in the catch block below</span></span><br><span class="line">    <span class="comment">// Any exceptions of type double thrown within the above try block get sent here</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"We caught an exception of type double"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str) &#123;</span><br><span class="line">    <span class="comment">// catch classes by const reference</span></span><br><span class="line">    <span class="comment">// Any exceptions of type std::string thrown within the above try block get sent here</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"We caught an exception of type std::string"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Continuing on our merry way\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Recapping exception handling</strong></p>
<p>Exception handling is actually quite simple, and the following two paragraphs cover most of what you need to remember about it:</p>
<p>When an exception is raised (using <code>throw</code>), execution of the program immediately <code>jumps to the nearest enclosing try block</code> (propagating up the stack if necessary to find an enclosing try block â€” weâ€™ll discuss this in more detail next lesson). If any of the catch handlers attached to the try block handle that type of exception, that handler is executed and the exception is considered handled.</p>
<p>If no appropriate catch handlers exist, execution of the program <code>propagates to the next enclosing try block</code>. If no appropriate catch handlers can be found before the end of the program, the program will fail with an exception error.</p>
<p>Note that the compiler <code>will not perform implicit conversions or promotions when matching exceptions with catch blocks</code>! For example, a char exception will not match with an int catch block. An int exception will not match a float catch block.</p>
<p>Thatâ€™s really all there is to it. The rest of this chapter will be dedicated to showing examples of these principles at work.</p>
<p><strong>Exceptions are handled immediately</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">4.5</span>; <span class="comment">// throw exception of type double</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This never prints\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>What catch blocks typically do</strong></p>
<ul>
<li>First, catch blocks may print an error (either to the console, or a log file).</li>
<li>Second, catch blocks may return a value or error code back to the caller.</li>
<li>Third, a catch block may <code>throw another exception</code>. Because the catch block is outside of the try block, the newly thrown exception in this case is not handled by the preceding try block â€” itâ€™s handled by the next enclosing try block.</li>
</ul>
<h3 id="Exceptions-functions-and-stack-unwinding"><a href="#Exceptions-functions-and-stack-unwinding" class="headerlink" title="Exceptions, functions, and stack unwinding"></a>Exceptions, functions, and stack unwinding</h3><p>In the examples in the previous lesson, the throw statements were placed directly <code>within</code> a try block. If this were a necessity, exception handling would be of limited use.</p>
<p>One of the most useful properties of exception handling is that the throw statements do NOT have to be placed directly inside a try block <code>due to the way exceptions propagate up the stack when thrown</code>. This allows us to use exception handling in a much more modular fashion. Weâ€™ll demonstrate this by rewriting the square root program from the previous lesson to use a modular function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// If the user entered a negative number, this is an error cond.</span></span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Can not take sqrt of negative number"</span>; <span class="comment">// throw exception of type const char*</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">  <span class="keyword">double</span> x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">double</span> d = mySqrt(x);</span><br><span class="line">    <span class="comment">// below code may not be executed</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sqrt of "</span> &lt;&lt; x &lt;&lt; <span class="string">" is "</span> &lt;&lt; d &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* exception) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error: "</span> &lt;&lt; exception &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* mySqrt() raised the exception, but the try/catch block in main() was the one who captured and handled the exception */</span></span><br><span class="line">  <span class="comment">/* Or, put another way, try blocks catch exceptions not only from statements within the try block, but also from functions that are called within the try block. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It does work! Letâ€™s revisit for a moment what happens when an exception is raised. </p>
<ul>
<li>First, the program looks to see if the exception can be handled immediately (which means it was thrown <code>inside a try block</code>). </li>
<li>If not, the current function is terminated, and the program checks to see if the <code>function&#39;s caller</code> will handle the exception (within the same try/catch block). </li>
<li>If not, it terminates the caller and checks the callerâ€™s caller. </li>
</ul>
<p>Each function is terminated in sequence until a handler for the exception is found, or until main() is terminated without the exception being handled. This process is called <code>unwinding the stack</code> (see the lesson on the stack and the heap if you need a refresher on what the call stack is).</p>
<p>By passing the error back up the stack, each application can handle an error from mySqrt() in a way that is the most context appropriate for it! Ultimately, <code>this keeps mySqrt() as modular as possible</code>, and the error handling can be placed in the less-modular parts of the code.</p>
<h3 id="Uncaught-exceptions-catch-all-handlers-and-exception-specifiers"><a href="#Uncaught-exceptions-catch-all-handlers-and-exception-specifiers" class="headerlink" title="Uncaught exceptions, catch-all handlers, and exception specifiers"></a>Uncaught exceptions, catch-all handlers, and exception specifiers</h3><p>When main() terminates with an unhandled exception, the operating system will generally notify you that an unhandled exception error has occurred. <code>How it does this depends on the operating system</code>, but possibilities include printing an error message, popping up an error dialog, or simply crashing. Some OSes are less graceful than others. Generally this is something you want to avoid altogether!</p>
<p>C++ provides us with a mechanism to catch all types of exceptions. This is known as a <code>catch-all handler</code>. A catch-all handler works just like a normal catch block, except that instead of using a specific type to catch, it uses the ellipses operator (â€¦) as the type to catch.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">5</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">double</span> x) &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught!"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Often, the catch-all handler block is left empty:</p>
<p>catch(â€¦) {} // ignore any unanticipated exceptions</p>
<p>This will catch any unanticipated exceptions and <code>prevent them from stack unwinding</code> to the top of your program, but does no specific error handling.</p>
<p><strong>Using the catch-all handler to wrap main()</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    runGame();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Abnormal termination\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  saveState(); <span class="comment">// Save user's game</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It gives us a chance to <code>print an error</code> of our choosing and then <code>save the user&#39;s state</code> before exiting. This can be useful to catch and handle problems that may be unanticipated.</p>
<p><strong>Exception specifiers</strong></p>
<p>This subsection should be considered optional reading because exception specifiers are <code>rarely used</code> in practice, are not well supported by compilers, and Bjarne Stroustrup (the creator of C++) considers them a <code>failed experiment</code>.</p>
<p>Exception specifiers are a mechanism that allows us to <code>use a function declaration to specify whether a function may or will not throw exceptions</code>. This can be useful in determining whether a function call needs to be put inside a try block or not. (In Java?)</p>
<p>First, we can use an <code>empty throw statement</code> to denote that a function does not throw any exceptions outside of itself:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// does not throw exceptions</span></span><br></pre></td></tr></table></figure>
<p>Note that doSomething() can still use exceptions as long as they are <code>handled internally</code>. Any function that is declared with throw() is supposed to cause the program to terminate <code>immediately</code> if it does try to throw an exception outside of itself, but implementation is spotty.</p>
<p>Second, we can use a specific throw statement to denote that a function may throw a particular type of exception:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// may throw a double</span></span><br></pre></td></tr></table></figure>
<p>Finally, we can use a catch-all throw statement to denote that a function may throw an unspecified type of exception:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> <span class="title">throw</span><span class="params">(...)</span></span>; <span class="comment">// may throw anything</span></span><br></pre></td></tr></table></figure>
<p>Due to the incomplete compiler implementation, the fact that exception specifiers are more like statements of intent than guarantees, some incompatibility with template functions, and the fact that most C++ programmers are unaware of their existence, I recommend you do not bother using exception specifiers.</p>
<p>C++11 added a fourth exception specifier that is actually getting some use: <code>noexcept</code>. <code>Noexcept</code> is a exception specifier that is used to indicate that a function can not throw an exception. Semantically, it allows you to see at a glance that a function will not throw an exception. It also potentially enables some compiler optimizations. Destructors are generally implicitly noexcept (as they canâ€™t throw an exception). <code>If a noexcept function does try to throw an exception, then std::terminate is called to terminate the application</code>.</p>
<p>Proper application of noexcept is non-trivial, and probably warrants its own lesson, so weâ€™ll leave it here â€” as a mention that it exists, but as a topic for advanced users to explore further.</p>
<h3 id="Exceptions-classes-and-inheritance"><a href="#Exceptions-classes-and-inheritance" class="headerlink" title="Exceptions, classes, and inheritance"></a>Exceptions, classes, and inheritance</h3><p><strong>Exceptions and member functions</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; IntArray::<span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">int</span> index) &#123;</span><br><span class="line">  assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; getLength());</span><br><span class="line">  <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now if the user passes in an invalid index, the program will cause an assertion error. While this is useful to indicate to the user that something went wrong, sometimes the better course of action is to <code>fail silently and let the caller know something went wrong</code> so they can deal with it as appropriate.</p>
<p>Unfortunately, <code>because overloaded operators have specific requirements as to the number and type of parameter(s) they can take and return, there is no flexibility for passing back error codes or boolean values to the caller</code>. However, since exceptions do not change the signature of a function, they can be put to great use here. Hereâ€™s an example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; IntArray::<span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">int</span> index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= getLength()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> index;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Constructors</code> are another area of classes in which exceptions can be very useful. If a constructor must fail for some reason (e.g. the user passed in invalid input), simply throw an exception to indicate the object failed to create. In such a case, the objectâ€™s construction is aborted, and <code>all class members</code> (which have already been created and initialized prior to the body of the constructor executing) are <code>destructed</code> as per usual. <code>However, the class&#39;s destructor is never called</code> (because the object never finished construction).</p>
<p>Because the destructor never executes, you can not rely on said destructor to clean up any resources that have already been allocated. <code>Any such cleanup can happen in the constructor prior to throwing the exception in the first place</code>. However, even better, because the members of the class are destructed as per usual, if you do the resource allocations in the members themselves, then those members can clean up after themselves when they are destructed.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_x;</span><br><span class="line">	Member m_member; <span class="comment">// it will be deallocated automatically</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> x) : m_x(x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~A() &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"~A\n"</span>; <span class="comment">// should not be called</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In the above program, when class A throws an exception, all of the members of A are destructed. This gives m_member an opportunity to clean up any resources that were allocated. This is part of the reason that RAII is advocated so highly.</p>
<p>Recap:</p>
<p>RAII (<code>Resource Acquisition Is Initialization</code>) is a programming technique whereby resource use is tied to the lifetime of objects with automatic duration (e.g. non-dynamically allocated objects). In C++, RAII is implemented via classes with constructors and destructors. (<code>allocation in the constructor, deallocation in the destructor</code>!)</p>
<p>Under the RAII paradigm, objects holding resources should not be dynamically allocated. This is because destructors are only called when an object is destroyed. For objects allocated on the stack, this happens automatically when the object goes out of scope, so thereâ€™s no need to worry about a resource eventually getting cleaned up. However, for dynamically allocated objects, the user is responsible for deletion â€” if the user forgets to do that, then the destructor will not be called, and the memory for both the class object and the resource being managed will be leaked!</p>
<p>Rule: If your class dynamically allocates memory, use the RAII paradigm, and donâ€™t allocate objects of your class dynamically</p>
<p><strong>Exception classes</strong></p>
<p>One of the major problems with using <code>basic data types</code> (such as int) as exception types is that they are inherently vague.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> *value = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="built_in">array</span>[index1] + <span class="built_in">array</span>[index2]);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">int</span> value) &#123;</span><br><span class="line">  <span class="comment">// What are we catching here?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exception class is just a normal class that is designed specifically to be thrown as an exception.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayException</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> m_error;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ArrayException(<span class="built_in">std</span>::<span class="built_in">string</span> error) : m_error(error) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getError</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_error.c_str(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage:</span></span><br><span class="line"><span class="comment">// throw ArrayException("Invalid index");</span></span><br><span class="line"><span class="comment">// catch (ArrayException &amp;exception)</span></span><br></pre></td></tr></table></figure>
<p>Note that exception handlers should catch class exception objects by reference instead of by value. This prevents the compiler from <code>making a copy</code> of the exception, which can be expensive when the exception is a class object, and <code>prevents object slicing</code> when dealing with derived exception classes (which weâ€™ll talk about in a moment). <code>Catching exceptions by pointer should generally be avoided unless you have a specific reason to do so</code>.</p>
<p><strong>Exceptions and inheritance</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> Derived();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Base &amp;base) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"caught Base"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Derived &amp;derived) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"caught Derived"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125; <span class="comment">/* output: caught Base */</span></span><br></pre></td></tr></table></figure>
<p><strong>Rule:</strong> Handlers for derived exception classes should be listed before those for base classes.</p>
<p><strong>std::exception</strong></p>
<p>Many of the classes and operators in the standard library throw exception classes on failure. For example, operator new and std::string can throw std::bad_alloc if they are unable to allocate enough memory. A failed dynamic_cast will throw std::bad_cast. And so on. As of C++14, there are 21 different exception classes that can be thrown, with more coming in C++17.</p>
<p>The good news is that all of these exception classes are derived from a single class called <code>std::exception</code>. <code>std::exception</code> is a small interface class designed to serve as a base class to any exception thrown by the C++ standard library.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">  s.resize(<span class="number">-1</span>); <span class="comment">// will trigger a std::bad_alloc</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::exception &amp;exception) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Standard exception: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or to handle specific type</span></span><br><span class="line"><span class="comment">// catch (std::bad_alloc &amp;exception) &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>The one thing worth noting is that std::exception has a virtual member function named what() that returns a C-style string description of the exception. Most derived classes override the what() function to change the message. Note that this string is <code>meant to be used for descriptive text only</code> â€” do not use it for comparisons, as it is not guaranteed to be the same across compilers.</p>
<p><code>Nothing throws a std::exception directly</code>, and neither should you. However, you should feel free to throw the other standard exception classes in the standard library if they adequately represent your needs.</p>
<p><code>std::runtime_error</code> (included as part of the stdexcept header) is a popular choice, because it has a generic name, and its constructor takes a customizable message.</p>
<p>Rewrite our ArrayException:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayException</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::exception &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> m_error;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ArrayException(<span class="built_in">std</span>::<span class="built_in">string</span> error) : m_error(error) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pre-C++11 version</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_error.c_str(); &#125;</span><br><span class="line">  <span class="comment">// C++11 version</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_error.c_str(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In C++11, virtual function what() was updated to have specifier noexcept (which means the function promises not to throw exceptions itself). Therefore, in C++11 and beyond, our override should also have specifier noexcept.</p>
<h3 id="Rethrowing-exceptions"><a href="#Rethrowing-exceptions" class="headerlink" title="Rethrowing exceptions"></a>Rethrowing exceptions</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIntValueFromDatabase</span><span class="params">(Database *d, <span class="built_in">std</span>::<span class="built_in">string</span> table, <span class="built_in">std</span>::<span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">  assert(d);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> d-&gt;getIntValue(table, key); <span class="comment">// throws int exception on failure</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">int</span> exception) &#123;</span><br><span class="line">    <span class="comment">// Write an error to some global logfile</span></span><br><span class="line">    g_log.logError(<span class="string">"doSomethingImportant failed"</span>);</span><br><span class="line">    <span class="comment">// However, we haven't actually handled this error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Throwing a new exception</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">int</span> exception) &#123;</span><br><span class="line">  g_log.logError(<span class="string">"doSomethingImportant failed"</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'q'</span>; <span class="comment">// throw char exception 'q' up the stack to be handled by caller</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the example above, the program catches the int exception from getIntValue(), logs the error, and then throws a new exception with char value â€˜qâ€™. Although it may seem weird to throw an exception from a catch block, this is allowed. <code>Remember, only exceptions thrown within a try block are eligible to be caught</code>. This means that <code>an exception thrown within a catch block will not be caught by the catch block it&#39;s in</code>. Instead, it will be propagated up the stack to the caller.</p>
<p><strong>Rethrowing an exception (the wrong way)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">int</span> exception) &#123;</span><br><span class="line">  g_log.logError(<span class="string">"doSomethingImportant failed"</span>);</span><br><span class="line">  <span class="keyword">throw</span> exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Although this works, this method has a couple of downsides:</p>
<ul>
<li>First, this doesnâ€™t throw the exact same exception as the one that is caught â€” rather, it throws a <code>copy-initialized copy</code> of variable exception. Although the compiler is free to elide the copy, it may not, so this could be less performant.</li>
<li><p>Second, it may cause unintended object slicing.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> d-&gt;getIntValue(table, key); <span class="comment">// throws Derived exception</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Base &amp;exception) &#123;</span><br><span class="line">  <span class="keyword">throw</span> exception; <span class="comment">// Danger: this throws a Base object, not a Derived object (object slicing)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Rethrowing an exception (the right way)</strong></p>
<p>Fortunately, C++ provides a way to rethrow the exact same exception as the one that was just caught. To do so, simply use the throw keyword from within the catch block (with no associated variable), like so:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> Derived();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Base&amp; b) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught Base b, which is actually a "</span>;</span><br><span class="line">    b.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">throw</span>; <span class="comment">// note: We're now rethrowing the object here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Base&amp; b) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught Base b, which is actually a "</span>;</span><br><span class="line">  b.print();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This throw keyword that doesnâ€™t appear to throw anything in particular actually re-throws the exact same exception that was just caught. <code>No copies are made</code>, meaning we donâ€™t have to worry about performance killing copies or slicing.</p>
<h3 id="Function-try-blocks"><a href="#Function-try-blocks" class="headerlink" title="Function try blocks"></a>Function try blocks</h3><p>Try and catch blocks work well enough in most cases, but there is one particular case in which they are not sufficient. Consider the following example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> x) : m_x(x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B(<span class="keyword">int</span> x) : A(x) &#123;</span><br><span class="line">		<span class="comment">// What happens if creation of A fails and we want to handle it here?</span></span><br><span class="line">    <span class="comment">// it backs to main()</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="function">B <span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (<span class="keyword">int</span>) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But what if we want to catch the exception inside of B? The call to base constructor A happens via the member initialization list, before the B constructorâ€™s body is called. Thereâ€™s no way to wrap a standard try block around it. In this situation, we have to use a slightly modified try block called a <code>function try block</code>.</p>
<p>Function try blocks are designed to allow you to <code>establish an exception handler around the body of an entire function</code>, rather than around a block of code.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class A ... same code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  B(<span class="keyword">int</span> x) <span class="keyword">try</span> : A(x) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Note the addition of the "try" keyword before the member initializer list. This indicates that everything after that point (until the end of the function) should be considered inside of the try block.</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (...) &#123; <span class="comment">// note this is at same level of indentation as the function itself</span></span><br><span class="line">    <span class="comment">// Exceptions from member initializer list or constructor body are caught here</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Construction of A failed"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown</span></span><br><span class="line">    <span class="comment">// which means, main() still catch the exception int and output Oops</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  output:</span></span><br><span class="line"><span class="comment">  Construction of A failed</span></span><br><span class="line"><span class="comment">  Oops</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Second, note that the associated catch block is at the same level of indentation as the entire function. Any exception thrown <code>between the try keyword and the end of the function body</code> will be eligible to be caught here.</p>
<p>Finally, unlike normal catch blocks, which allow you to either resolve an exception, throw a new exception, or rethrow an existing exception, with function-level try blocks, <code>you must throw or rethrow an exception</code>. If you do not explicitly throw a new exception, or rethrow the current exception, the exception will be implicitly rethrown up the stack.</p>
<p>Although function level try blocks can be used with non-member functions as well, they typically arenâ€™t because thereâ€™s rarely a case where this would be needed. <code>They are almost exclusively used with constructors</code>!</p>
<p><strong>Donâ€™t use function try to clean up resources</strong></p>
<p>When construction of an object fails, the destructor of the class is not called. Consequently, you may be tempted to use a function try block as a way to clean up a class that had partially allocated resources before failing. However, <code>referring to members of the failed object is considered undefined behavior since the object is &quot;dead&quot; before the catch block executes</code>. This means that you canâ€™t use function try to clean up after a class. If you want to clean up after a class, follow the standard rules for cleaning up classes that throw exceptions.</p>
<p>Function try is useful primarily for either logging failures before passing the exception up the stack, or for changing the type of exception thrown.</p>
<h3 id="Exception-dangers-and-downsides"><a href="#Exception-dangers-and-downsides" class="headerlink" title="Exception dangers and downsides"></a>Exception dangers and downsides</h3><p><strong>Cleaning up resources</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  openFile(filename);</span><br><span class="line">  writeFile(filename, data);</span><br><span class="line">  closeFile(filename);</span><br><span class="line">  <span class="comment">// the file was never close if exceptions were thrown in the functions above</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileException &amp;exception) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write to file: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This example should be rewritten as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  openFile(filename);</span><br><span class="line">  writeFile(filename, data);</span><br><span class="line">  closeFile(filename);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileException &amp;exception) &#123;</span><br><span class="line">  <span class="comment">// Make sure file is closed</span></span><br><span class="line">  closeFile(filename);</span><br><span class="line">  <span class="comment">// Then write error</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write to file: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This kind of error often crops up in another form when dealing with dynamically allocated memory:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Person *john = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">18</span>, PERSON_MALE);</span><br><span class="line">  processPerson(john);</span><br><span class="line">  <span class="keyword">delete</span> john;</span><br><span class="line">&#125; <span class="keyword">catch</span> (PersonException &amp;exception) &#123;</span><br><span class="line">  <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to process person: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This example is a little more tricky than the previous one â€” because john is local to the try block, it goes out of scope when the try block exits. So thereâ€™s no way for it to deallocate the memory. However, there are two relatively easy ways to fix this.</p>
<p>First:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person *john = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  john = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">18</span>, PERSON_MALE);</span><br><span class="line">  processPerson(john);</span><br><span class="line">  <span class="keyword">delete</span> john;</span><br><span class="line">&#125; <span class="keyword">catch</span> (PersonException &amp;exception) &#123;</span><br><span class="line">  <span class="keyword">delete</span> john;</span><br><span class="line">  <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to process person: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Second: use a local variable of a class that knows how to cleanup itself when it goes out of scope (often called â€œsmart pointerâ€). The STL provides a class called <code>std::unique_ptr</code> that can be used for this purpose. <code>std::unique_ptr</code> is a template class that holds a pointer, and deallocates it when it goes out of scope.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Person *john = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">18</span>, PERSON_MALE);</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Person&gt; upJohn(john); <span class="comment">// upJohn now owns john</span></span><br><span class="line">  ProcessPerson(john);</span><br><span class="line">  <span class="comment">// when upJohn goes out of scope, it will delete john</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (PersonException &amp;exception) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to process person: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Exceptions and destructors</strong></p>
<p>Unlike constructors, where throwing exceptions can be a useful way to indicate that object creation did not succeed, <code>exceptions should never be thrown in destructors</code>.</p>
<p>The problem occurs when an exception is thrown from a destructor <code>during the stack unwinding process</code>. If that happens, the compiler is put in a situation where it doesnâ€™t know whether to continue the stack unwinding process or handle the new exception. The end result is that your program will be terminated immediately.</p>
<p>The alternative way is to write a message to a log file instead.</p>
<p><strong>Performance concerns</strong></p>
<p>The main performance penalty for exceptions happens <code>when an exception is actually thrown</code>. In this case, the stack must be unwound and an appropriate exception handler found, which is a relatively expensive operation.</p>
<p>As a note, some modern computer architectures support an exception model called <code>zero-cost exceptions</code>. Zero-cost exceptions, if supported, have no additional runtime cost in the non-error case (which is the case we most care about performance). <code>However, they incur an even larger penalty in the case where an exception is found.</code></p>
<p><strong>So when should I use exceptions?</strong></p>
<ul>
<li>The error being handled is likely to occur only infrequently.</li>
<li>The error is serious and execution could not continue otherwise.</li>
<li>The error cannot be handled at the place where it occurs.</li>
<li>There isnâ€™t a good alternative way to return an error code back to the caller.</li>
<li></li>
</ul>
<h2 id="Move-semantics-and-smart-pointers"><a href="#Move-semantics-and-smart-pointers" class="headerlink" title="Move semantics and smart pointers"></a>Move semantics and smart pointers</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Resource *ptr = <span class="keyword">new</span> Resource;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an integer: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// the function returns early, and ptr won't be deleted!</span></span><br><span class="line">  <span class="comment">// do stuff with ptr here</span></span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One of the best things about classes is that they <code>contain destructors that automatically get executed when an object of the class goes out of scope</code>. So if you allocate (or acquire) memory in your constructor, you can deallocate it in your destructor, and be guaranteed that the memory will be deallocated when the class object is destroyed (regardless of whether it goes out of scope, gets explicitly deleted, etcâ€¦). This is at the heart of the RAII programming paradigm that we talked about in lesson 8.7 â€” Destructors.</p>
<p>So can we use a class to help us manage and clean up our pointers? We can! Consider a class whose sole job was to hold and â€œownâ€ a pointer passed to it, and then deallocate that pointer when the class object went out of scope. As long as objects of that class were only created as local variables, we could guarantee that the class would properly go out of scope (regardless of when or how our functions terminate) and the owned pointer would get destroyed.</p>
<p>Hereâ€™s a first draft of the idea:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr1</span> &#123;</span></span><br><span class="line">  T *m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Auto_ptr1(T *ptr=<span class="literal">nullptr</span>) : m_ptr(ptr) &#123;&#125;</span><br><span class="line">  ~Auto_ptr1() &#123; <span class="keyword">delete</span> m_ptr; &#125;</span><br><span class="line">  <span class="comment">// ... overloaed operators</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sameple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> &#123;</span></span><br><span class="line">  Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">  ~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Auto_ptr1&lt;Resource&gt; res(<span class="keyword">new</span> Resource);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    output:</span></span><br><span class="line"><span class="comment">    Resource acquired</span></span><br><span class="line"><span class="comment">    Resource destroyed</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// res goes out of scope here, and destroys the allocated Resource for us</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Such a class is called a smart pointer. A <code>Smart pointer</code> is a <code>composition class</code> that is designed to manage dynamically allocated memory and ensure that memory gets deleted when the smart pointer object goes out of scope. (Relatedly, built-in pointers are sometimes called <code>dumb pointers</code> because they canâ€™t clean up after themselves).</p>
<p><strong>A critical flaw</strong></p>
<p>The Auto_ptr1 class has a critical flaw lurking behind some auto-generated code. Before reading further, see if you can identify what it is. Weâ€™ll waitâ€¦</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Auto_ptr1&lt;Resource&gt; res1(<span class="keyword">new</span> Resource);</span><br><span class="line">  Auto_ptr1&lt;Resource&gt; res2(res1);</span><br><span class="line">  <span class="comment">// Alternatively, don't initialize res2 and then assign res2 = res1;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Resource acquired</span></span><br><span class="line"><span class="comment">    Resource destroyed</span></span><br><span class="line"><span class="comment">    Resource destroyed</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Very likely (but not necessarily) your program will crash at this point. See the problem now? <code>Because we haven&#39;t supplied a copy constructor or an assignment operator, C++ provides one for us</code>. And the functions it provides do <code>shallow copies</code>. So when we initialize res2 with res1, both Auto_ptr1 variables are pointed at the same Resource. When res2 goes out of the scope, it deletes the resource, leaving res1 with a dangling pointer. When res1 goes to delete its (already deleted) Resource, crash!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passByValue</span><span class="params">(Auto_ptr1&lt;Resource&gt; res)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Auto_ptr1&lt;Resource&gt; res1(<span class="keyword">new</span> Resource);</span><br><span class="line">	passByValue(res1)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this program, res1 will be copied by value into passByValueâ€™s parameter res, leading to duplication of the Resource pointer. Crash!</p>
<p>So clearly this isnâ€™t good. How can we address this?</p>
<p>Well, one thing we could do would be to <code>explicitly define and delete the copy constructor and assignment operator</code>, thereby preventing any copies from being made in the first place. That would prevent the pass by value case (which is good, we probably shouldnâ€™t be passing these by value anyway).</p>
<p>But then how would we return an Auto_ptr1 from a function back to the caller?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">??? generateResource() &#123;</span><br><span class="line">  Resource *r = <span class="keyword">new</span> Resource;</span><br><span class="line">  <span class="keyword">return</span> Auto_ptr1(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We canâ€™t return our Auto_ptr1 by reference, because the local Auto_ptr1 will be destroyed at the end of the function, and the caller will be left with a dangling reference. Return by address has the same problem. We could return pointer r by address, but then we might forget to delete r later, which is the whole point of using smart pointers in the first place. So thatâ€™s out. <code>Returning the Auto_ptr1 by value is the only option that makes sense</code> â€” but then we end up with <code>shallow copies</code>, duplicated pointers, and crashes.</p>
<p>Another option would be to override the copy constructor and assignment operator to make deep copies. In this way, weâ€™d at least guarantee to avoid duplicate pointers to the same object. But copying can be expensive (and may not be desirable or even possible), and we donâ€™t want to make needless copies of objects just to return an Auto_ptr1 from a function. Plus assigning or initializing a dumb pointer doesnâ€™t copy the object being pointed to, so why would we expect smart pointers to behave differently?</p>
<p><strong>Move semantics</strong></p>
<p>What if, instead of having our copy constructor and assignment operator copy the pointer (â€œcopy semanticsâ€), we instead transfer/<code>move ownership of the pointer from the source to the destination object</code>? This is the core idea behind move semantics. Move semantics means the class will transfer ownership of the object rather than making a copy.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A copy constructor that implements move semantics</span></span><br><span class="line">Auto_ptr2(Auto_ptr2 &amp;a) &#123;</span><br><span class="line">  m_ptr = a.m_ptr; <span class="comment">// transfer our dumb pointer from the source to our local object</span></span><br><span class="line">  a.m_ptr = <span class="literal">nullptr</span>;  <span class="comment">// make sure the source no longer owns the pointer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// An assignment operator that implements move semantics</span></span><br><span class="line">Auto_ptr2&amp; <span class="keyword">operator</span>= (Auto_ptr2 &amp;a) &#123;  <span class="comment">// note: not const</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">delete</span> m_ptr; <span class="comment">// make sure we deallocate any pointer the destination is already holding first</span></span><br><span class="line">  m_ptr = a.m_ptr; <span class="comment">// then transfer our dumb pointer from the source to the local object</span></span><br><span class="line">  a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// make sure the source no long owns the pointer</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Auto_ptr2&lt;Resource&gt; res1(<span class="keyword">new</span> Resource);</span><br><span class="line">  Auto_ptr2&lt;Resource&gt; res2; <span class="comment">// start as nullptr</span></span><br><span class="line"></span><br><span class="line">  res2 = res1;  <span class="comment">// res2 assumes ownership, res1 is set to null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>std::auto_ptr, and why to avoid it</strong></p>
<p>Now would be an appropriate time to talk about std::auto_ptr. std::auto_ptr, introduced in C++98, was C++â€™s first attempt at a standardized smart pointer. std::auto_ptr opted to implement move semantics just like the Auto_ptr2 class does.</p>
<p>However, std::auto_ptr (and our Auto_ptr2 class) has a number of problems that makes using it dangerous.</p>
<p>First, because std::auto_ptr implements move semantics through the copy constructor and assignment operator, <code>passing a std::auto_ptr by value to a function will cause your resource to get moved to the function parameter (and be destroyed at the end of the function when the function parameters go out of scope)</code>. Then when you go to access your auto_ptr argument from the caller (not realizing it was transferred and deleted), youâ€™re suddenly dereferencing a null pointer. Crash!</p>
<p>Second, <code>std::auto_ptr always deletes its contents using non-array delete</code>. This means auto_ptr wonâ€™t work correctly with dynamically allocated arrays, because it uses the wrong kind of deallocation. Worse, it wonâ€™t prevent you from passing it a dynamic array, which it will then mismanage, leading to memory leaks.</p>
<p>Finally, auto_ptr doesnâ€™t play nice with a lot of the other classes in the standard library, including most of the containers and algorithms. This occurs because those standard library classes assume that when they copy an item, it actually makes a copy, not does a move.</p>
<p><code>Because of the above mentioned shortcomings, std::auto_ptr has been deprecated in C++11, and it should not be used. In fact, std::auto_ptr is slated for complete removal from the standard library as part of C++17!</code></p>
<p><strong>Rule:</strong> std::auto_ptr is deprecated and should not be used. (Use std::unique_ptr or std::shared_ptr instead)..</p>
<p><strong>Moving forward</strong></p>
<p>The core problem with the design of std::auto_ptr is that prior to C++11, the C++ language simply had no mechanism to differentiate â€œcopy semanticsâ€ from â€œmove semanticsâ€. <code>Overriding the copy semantics to implement move semantics leads to weird edge cases and inadvertent bugs</code>. For example, you can write res1 = res2 and have no idea whether res2 will be changed or not!</p>
<p>Because of this, in C++11, the concept of â€œmoveâ€ was formally defined, and â€œmove semanticsâ€ were added to the language to properly differentiate copying from moving. Now that weâ€™ve set the stage for why move semantics can be useful, weâ€™ll explore the topic of move semantics throughout the rest of this chapter. Weâ€™ll also fix our Auto_ptr2 class using move semantics.</p>
<p>In C++11, std::auto_ptr has been replaced by a bunch of other types of â€œmove-awareâ€ smart pointers: <code>std::scoped_ptr</code>, <code>std::unique_ptr</code>, <code>std::weak_ptr</code>, and <code>std::shared_ptr</code>. Weâ€™ll also explore the two most popular of these: unique_ptr (which is a direct replacement for auto_ptr) and shared_ptr.</p>
<h3 id="R-value-reference"><a href="#R-value-reference" class="headerlink" title="R-value reference"></a>R-value reference</h3><p>The topic of l-values and r-values is very important to understand move semantics in C++11.</p>
<p><strong>L-values and r-values</strong></p>
<p>Despite having the word â€œvalueâ€ in their names, l-values and r-values are actually not properties of values, but rather, <code>properties of expressions</code>.</p>
<p>Every expression in C++ has two properties: a <code>type</code> (which is used for <code>type checking</code>), and a <code>value</code> category (which is used for certain kinds of <code>syntax checking</code>, such as whether the result of the expression can be assigned to). In C++03 and earlier, l-values and r-values were the only two value categories available.</p>
<p>The actual definition of which expressions are l-values and which are r-values is surprisingly <code>complicated</code>, so weâ€™ll take a simplified view of the subject that will largely suffice for our purposes.</p>
<p><strong>L-value: Locator values</strong></p>
<p>Itâ€™s simplest to think of an <code>l-value</code> (also called a <code>locator value</code>) as a function or an object (or an expression that evaluates to a function or object). <code>All l-values have assigned memory addresses</code>.</p>
<p>When l-values were originally defined, they were defined as â€œvalues that are suitable to be on the <code>left-hand side</code> of an assignment expressionâ€. <strong>However</strong>, later, the <code>const</code> keyword was added to the language, and l-values were split into <code>two sub-categories</code>: <code>modifiable l-values</code>, which can be changed, and <code>non-modifiable l-values</code>, which are const.</p>
<p><strong>R-value: everything that is not an l-value</strong></p>
<p>Itâ€™s simplest to think of an r-value as â€œeverything that is not an l-valueâ€. This notably includes <code>literals</code> (e.g. 5), <code>temporary values</code> (e.g. x+1), and <code>anonymous objects</code> (e.g. Fraction(5, 2)).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fraction &amp;frac = Fraction(<span class="number">5</span>, <span class="number">2</span>); <span class="comment">// error</span></span><br><span class="line"><span class="comment">// values assigned to references should be l-values.</span></span><br></pre></td></tr></table></figure>
<p>R-values are typically evaluated for their values, have <code>expression scope</code> (they die at the end of the expression they are in), and cannot be assigned to. This non-assignment rule makes sense, because assigning a value applies a side-effect to the object. Since r-values have expression scope, if we were to assign a value to an r-value, then the r-value would either go out of scope before we had a chance to use the assigned value in the next expression (which makes the assignment useless) or weâ€™d have to use a variable with a side effect applied more than once in an expression (which by now you should know causes undefined behavior!).</p>
<p>In order to support move semantics, C++11 introduces 3 new value categories: <code>pr-values</code>, <code>x-values</code>, and <code>gl-values</code>. We will largely ignore these since understanding them isnâ€™t necessary to learn about or use move semantics effectively. If youâ€™re interested, <a href="cppreference.com">cppreference.com</a> has an extensive list of expressions that qualify for each of the various value categories, as well as more detail about them.</p>
<p><strong>L-value references</strong></p>
<p>Prior to C++11, only one type of reference existed in C++, and so it was just called a â€œreferenceâ€. However, in C++11, itâ€™s sometimes called an l-value reference. L-value references can only be initialized with modifiable l-values.</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/2f2di.jpg" alt=""></p>
<p><code>L-value references to const objects</code> can be initialized with l-values and r-values alike. However, those values canâ€™t be modified.</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/hsqjw.jpg" alt=""></p>
<p>L-value references to const objects are particularly useful because they allow us to pass any type of argument (l-value or r-value) into a function without making a copy of the argument.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Fraction &amp;frac = Fraction(); <span class="comment">// allowed</span></span><br><span class="line">Fraction &amp;frac = Fraction(); <span class="comment">// now allowed</span></span><br></pre></td></tr></table></figure>
<p><strong>R-value references</strong></p>
<p>C++11 adds a new type of reference called an r-value reference. An r-value reference is a reference that is designed to be <code>initialized with an r-value (only)</code>. While an l-value reference is created using a single ampersand, an r-value reference is created using a <code>double ampersand</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;lref = x;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rref = <span class="number">5</span>;  <span class="comment">// r-value reference initialized with r-value 5</span></span><br></pre></td></tr></table></figure>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/jdw9p.jpg" alt=""></p>
<p>R-value references have two properties that are useful:</p>
<ul>
<li>First, r-value references <code>extend the lifespan</code> of the object they are initialized with to the lifespan of the r-value reference (l-value references to const objects can do this too). </li>
<li>Second, non-const r-value references allow you to modify the r-value!</li>
</ul>
<p>While it may seem weird to initialize an r-value reference with a literal value and then be able to change that value, when initializing an r-value with a literal, a temporary is constructed from the literal so that the reference is <code>referencing a temporary object</code>, not a literal value.</p>
<p>R-value references are <code>not very often used</code> in either of the manners illustrated above.</p>
<p><strong>R-value references as function parameters</strong></p>
<p>R-value references are more often used as function parameters. This is most useful for function overloads when you want to have different behavior for l-value and r-value arguments.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;lref)</span> </span>&#123; <span class="comment">// l-value arguments will select this function</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"l-value reference to const\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> &amp;&amp;rref)</span> </span>&#123; <span class="comment">// r-value arguments will select this function</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"r-value reference\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">	fun(x); <span class="comment">// l-value argument calls l-value version of function</span></span><br><span class="line">	fun(<span class="number">5</span>); <span class="comment">// r-value argument calls r-value version of function</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is considered a better match than a l-value reference to const, since the 1st one can also match literals.</p>
<p>One interesting note:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref = <span class="number">5</span>;</span><br><span class="line">fun(ref);</span><br></pre></td></tr></table></figure>
<p>actually calls the <code>l-value version of the function</code>! Although variable ref has type r-value reference to an integer, it is actually an l-value itself (as are all named variables). The confusion stems from the use of the term r-value in two different contexts. Think of it this way: <code>Named-objects are l-values. Anonymous objects are r-values</code>. </p>
<p>The type of the named object or anonymous object is independent from whether itâ€™s an l-value or r-value. Or, put another way, if r-value reference had been called anything else, this confusion wouldnâ€™t exist.</p>
<blockquote>
<p>I donâ€™t understand this part. I just understand that <code>ref</code> in this case should be treated as a named object because it has a name!</p>
</blockquote>
<p><strong>Returning an r-value reference</strong></p>
<p><code>You should almost never return an r-value reference, for the same reason you should almost never return an l-value reference.</code> In most cases, youâ€™ll end up returning a hanging reference when the referenced object goes out of scope at the end of the function.</p>
<blockquote>
<p>Just like a pointer referring to a local variable?</p>
</blockquote>
<h3 id="Move-constructors-and-move-assignment"><a href="#Move-constructors-and-move-assignment" class="headerlink" title="Move constructors and move assignment"></a>Move constructors and move assignment</h3><p><strong>Copy constructors and copy assignment (recap)</strong></p>
<p>Copy constructors are used to initialize a <code>new</code> class by making a copy of an object of the same class. Copy assignment is used to copy one class to another <code>existing</code> class.</p>
<p>By default, C++ will provide a copy constructor and copy assignment operator if one is not explicitly provided. These compiler-provided functions <code>do shallow copies</code>, which may cause problems for classes that allocate dynamic memory. So classes that deal with dynamic memory should <code>override</code> these functions to <code>do deep copies</code>.</p>
<p>Returning back to our Auto_ptr smart pointer class example from the first lesson in this chapter, letâ€™s look at a version that implements a copy constructor and copy assignment operator that do deep copies, and a sample program that exercises them:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr3</span> &#123;</span></span><br><span class="line">  T *m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Auto_ptr3(T *ptr = <span class="literal">nullptr</span>) : m_ptr(ptr) &#123;&#125;</span><br><span class="line">  <span class="comment">// Copy constructor</span></span><br><span class="line">  ~Auto_ptr3() &#123; <span class="keyword">delete</span> m_ptr; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy constructor</span></span><br><span class="line">  <span class="comment">// Do deep copy of a.m_ptr to m_ptr</span></span><br><span class="line">  Auto_ptr3(<span class="keyword">const</span> Auto_ptr3&amp; a) &#123;</span><br><span class="line">    m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">    *m_ptr = *a.m_ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy assignment</span></span><br><span class="line">  <span class="comment">// Do deep copy of a.m_ptr to m_ptr</span></span><br><span class="line">  Auto_ptr3&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Auto_ptr3&amp; a) &#123;</span><br><span class="line">    <span class="comment">// Self-assignment detection</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Release any resource we're holding</span></span><br><span class="line">    <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    <span class="comment">// Copy the resource</span></span><br><span class="line">    m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">    *m_ptr = *a.m_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// skip overloaded operators</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Acquired"</span> &lt;&lt; <span class="string">"\n"</span>; &#125;</span><br><span class="line">  ~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destroyed"</span> &lt;&lt; <span class="string">"\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Auto_ptr3&lt;Resource&gt; generateResource() &#123;</span><br><span class="line">  Auto_ptr3&lt;Resource&gt; res(<span class="keyword">new</span> Resource);</span><br><span class="line">  <span class="keyword">return</span> res; <span class="comment">// this return value will invoke the copy construcor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Auto_ptr3&lt;Resource&gt; marires;</span><br><span class="line">  mainres = generateResource();  <span class="comment">// this assignment will invoke the copy assignment</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  output: 3 "Acquired" 3 "Destroyed"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* you may only get 4 outputs if your compiler does elides the return value from function generateResource() */</span></span><br></pre></td></tr></table></figure>
<p>Thatâ€™s a lot of resource creation and destruction going on for such a simple program! Whatâ€™s going on here?</p>
<p>So, in short, because we call the copy constructor once to copy construct res to a temporary, and copy assignment once to copy the temporary into mainres, we end up allocating and destroying 3 separate objects in total. Inefficient, but at least it doesnâ€™t crash!</p>
<p>However, with move semantics, we can do better.</p>
<p><strong>Move constructors and move assignment</strong></p>
<p>C++11 defines two new functions in service of move semantics: a move constructor, and a move assignment operator. Whereas the goal of the copy constructor and copy assignment is to make a copy of one object to another, <code>the goal of the move constructor and move assignment is to move ownership of the resources from one object to another (which is much less expensive than making a copy)</code>.</p>
<p>Defining a move constructor and move assignment work analogously to their copy counterparts. However, whereas the copy flavors of these functions take a const l-value reference parameter, <code>the move flavors of these functions use non-const r-value reference parameters</code>.</p>
<p>Hereâ€™s the same Auto_ptr3 class as above, with a move constructor and move assignment operator added. Weâ€™ve left in the deep-copying copy constructor and copy assignment operator for comparison purposes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy constructor</span></span><br><span class="line"><span class="comment">// Do deep copy of a.m_ptr to m_ptr</span></span><br><span class="line">Auto_ptr4(<span class="keyword">const</span> Auto_ptr4&amp; a) &#123;</span><br><span class="line">  m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">  *m_ptr = *a.m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move constructor</span></span><br><span class="line"><span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">Auto_ptr4(Auto_ptr4&amp;&amp; a)   <span class="comment">// r-value reference</span></span><br><span class="line">  : m_ptr(a.m_ptr) &#123;</span><br><span class="line">  a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// we'll talk more about this line below</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy assignment</span></span><br><span class="line"><span class="comment">// Do deep copy of a.m_ptr to m_ptr</span></span><br><span class="line">Auto_ptr4&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Auto_ptr4&amp; a) &#123;</span><br><span class="line">  <span class="comment">// Self-assignment detection</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release any resource we're holding</span></span><br><span class="line">  <span class="keyword">delete</span> m_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy the resource</span></span><br><span class="line">  m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">  *m_ptr = *a.m_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move assignment</span></span><br><span class="line"><span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">Auto_ptr4&amp; <span class="keyword">operator</span>= (Auto_ptr4&amp;&amp; a) &#123;</span><br><span class="line">  <span class="comment">// Self-assignment detection</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release any resource we're holding</span></span><br><span class="line">  <span class="keyword">delete</span> m_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">  m_ptr = a.m_ptr;</span><br><span class="line">  a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// we'll talk more about this line below</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Auto_ptr4&lt;Resource&gt; generateResource() &#123;</span><br><span class="line">  Auto_ptr4&lt;Resource&gt; res(<span class="keyword">new</span> Resource);</span><br><span class="line">  <span class="keyword">return</span> res; <span class="comment">// this return value will invoke the move constructor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Auto_ptr4&lt;Resource&gt; mainres;</span><br><span class="line">  mainres = generateResource();</span><br><span class="line">  <span class="comment">// this assignment will invoke the move assignment</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  output: 1 "Acquired" 1 "Destroyed"</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>The move constructor and move assignment operator are simple. Instead of deep copying the source object (a) into the implicit object, we simply move (steal) the source objectâ€™s resources. This involves shallow copying the source pointer into the implicit object, then setting the source pointer to null.</p>
<ol>
<li>Inside generateResource(), local variable res is created and initialized with a dynamically allocated Resource, which causes the first â€œResource acquiredâ€.</li>
<li>Res is returned back to main() by value. Res is <code>move constructed</code> into a <code>temporary object</code>, transferring the dynamically created object stored in res to the temporary object. Weâ€™ll talk about why this happens below.</li>
<li><code>Res goes out of scope</code> (but its data has been transferred already). Because res no longer manages a pointer (it was moved to the temporary), nothing interesting happens here.</li>
<li><code>The temporary object</code> is <code>move assigned</code> to mainres. This transfers the dynamically created object stored in the temporary to mainres.</li>
<li>The assignment expression ends, and <code>the temporary object goes out of expression scope</code> and is destroyed. However, because the temporary no longer manages a pointer (it was moved to mainres), nothing interesting happens here either.</li>
<li>At the end of main(), mainres goes out of scope, and our final â€œResource destroyedâ€ is displayed.</li>
</ol>
<p>So instead of copying our Resource twice (once for the copy constructor and once for the copy assignment), we transfer it twice. This is more efficient, as Resource is only constructed and destroyed once instead of three times.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Auto_ptr4&lt;Resource&gt; res(<span class="keyword">new</span> Resource); <span class="comment">// copy constructor called</span></span><br><span class="line"><span class="comment">// at the end</span></span><br></pre></td></tr></table></figure>
<p><strong>When are the move constructor and move assignment called?</strong></p>
<p>The move constructor and move assignment are called <code>when those functions have been defined</code>, and <code>the argument for construction or assignment is an r-value</code>. Most typically, this r-value will be a <code>literal</code> or <code>temporary value</code>.</p>
<p>In most cases, a move constructor and move assignment operator will <code>not be provided by default</code>, unless the class does not have any defined copy constructors, copy assignment, move assignment, or destructors. However, <code>the default move constructor and move assignment do the same thing as the default copy constructor and copy assignment (make copies, not do moves).</code></p>
<p><strong>Rule:</strong> If you want a move constructor and move assignment that do moves, youâ€™ll need to write them yourself.</p>
<p><strong>The key insight behind move semantics</strong></p>
<p>You now have enough context to understand the key insight behind move semantics.</p>
<p>If we construct an object or do an assignment where the argument is an l-value, the only thing we can reasonably do is copy the l-value. <code>We can&#39;t assume it&#39;s safe to alter the l-value, because it may be used again later in the program</code>. If we have an expression â€œa = bâ€, we wouldnâ€™t reasonably expect b to be changed in any way.</p>
<p>However, if we construct an object or do an assignment where the argument is an r-value, <code>then we know that r-value is just a temporary object of some kind</code>. Instead of copying it (which can be expensive), we can simply transfer its resources (which is cheap) to the object weâ€™re constructing or assigning. This is safe to do because the temporary will be destroyed at the end of the expression anyway, so <code>we know it will never be used again</code>!</p>
<p>C++11, through r-value references, gives us the ability to provide different behaviors when the argument is an r-value vs an l-value, enabling us to make smarter and more efficient decisions about how our objects should behave.</p>
<p><strong>Move functions should always leave both objects in a well-defined state</strong></p>
<p>In the above examples, both the move constructor and move assignment functions set a.m_ptr to nullptr. This may seem extraneous â€” after all, if â€œaâ€ is a temporary r-value, why bother doing â€œcleanupâ€ if parameter â€œaâ€ is going to be destroyed anyway?</p>
<p>The answer is simple: When â€œaâ€ goes out of scope, aâ€™s destructor will be called, and a.m_ptr will be deleted. If at that point, a.m_ptr is still pointing to the same object as m_ptr, <code>then m_ptr will be left as a dangling pointer</code>. When the object containing m_ptr eventually gets used (or destroyed), weâ€™ll get undefined behavior.</p>
<p>Additionally, in the next lesson weâ€™ll see cases where â€œaâ€ can be an l-value. In such a case, â€œaâ€ wouldnâ€™t be destroyed immediately, and could be queried further before its lifetime ends.</p>
<p><strong>Automatic l-values returned by value may be moved instead of copied</strong></p>
<p>In the generateResource() function of the Auto_ptr4 example above, when variable res is returned by value, <code>it is moved instead of copied</code>, even though res is an l-value. <code>The C++ specification has a special rule that says automatic objects returned from a function by value can be moved even if they are l-values</code>. This makes sense, since res was going to be destroyed at the end of the function anyway! We might as well steal its resources instead of making an expensive and unnecessary copy.</p>
<blockquote>
<p>ä¸€ä¸ªå±€éƒ¨å˜é‡å¯¹è±¡åœ¨è¿”å›žçš„æ—¶å€™ä¼šè¢«å½“åš r-value å¤„ç†ã€‚</p>
</blockquote>
<p>Although the compiler can move l-value return values, in some cases it may be able to do even better by simply eliding the copy altogether (which avoids the need to make a copy or do a move at all). In such a case, neither the copy constructor nor move constructor would be called.</p>
<p><strong>Disabling copying</strong></p>
<p>In the Auto_ptr4 class above, we left in the copy constructor and assignment operator for comparison purposes. But in move-enabled classes, <code>it is sometimes desirable to delete the copy constructor and copy assignment functions to ensure copies aren&#39;t made</code>. In the case of our Auto_ptr class, we donâ€™t want to copy our templated object T â€” both because itâ€™s expensive, and whatever class T is may not even support copying!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Auto_ptr5(<span class="keyword">const</span> Auto_ptr5&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">Auto_ptr5&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Auto_ptr5&amp; a) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<p><code>If you were to try to pass an Auto_ptr5 l-value to a function by value, the compiler would complain that the copy constructor required to initialize the copy constructor argument has been deleted.</code> This is good, because we should probably be passing Auto_ptr5 by const l-value reference anyway!</p>
<p>Auto_ptr5 is (finally) a good smart pointer class. And, in fact the standard library contains a class very much like this one (that you should use instead), named <code>std::unique_ptr</code>. Weâ€™ll talk more about std::unique_ptr later in this chapter.</p>
<p>Another example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy constructor</span></span><br><span class="line">DynamicArray(<span class="keyword">const</span> DynamicArray &amp;arr) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">// Copy assignment</span></span><br><span class="line">DynamicArray&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> DynamicArray &amp;arr) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move constructor</span></span><br><span class="line">DynamicArray(DynamicArray &amp;&amp;arr)</span><br><span class="line">  : m_length(arr.m_length), m_array(arr.m_array) &#123;</span><br><span class="line">  arr.m_length = <span class="number">0</span>;</span><br><span class="line">  arr.m_array = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move assignment</span></span><br><span class="line">DynamicArray&amp; <span class="keyword">operator</span>= (DynamicArray &amp;&amp;arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;arr == <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] m_array;</span><br><span class="line"></span><br><span class="line">  m_length = arr.m_length;</span><br><span class="line">  m_array = arr.m_array;</span><br><span class="line">  arr.m_length = <span class="number">0</span>;</span><br><span class="line">  arr.m_array = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a copy of arr with all of the values doubled</span></span><br><span class="line">DynamicArray&lt;<span class="keyword">int</span>&gt; cloneArrayAndDouble(<span class="keyword">const</span> DynamicArray&lt;<span class="keyword">int</span>&gt; &amp;arr) &#123;</span><br><span class="line">	DynamicArray&lt;<span class="keyword">int</span>&gt; dbl(arr.getLength());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.getLength(); ++i)</span><br><span class="line">		dbl[i] = arr[i] * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> dbl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  DynamicArray&lt;<span class="keyword">int</span>&gt; arr(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.getLength(); ++i)</span><br><span class="line">    arr[i] = i;</span><br><span class="line">  arr = cloneArrayAndDouble(arr);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compare Copy &amp; Move versions:</p>
<p>On the same machine, this program executed in 0.0056 seconds.</p>
<p>Comparing the runtime of the two programs, 0.0056 / 0.00825559 = 67.8%. The move version was almost 33% faster!</p>
<h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p>Once you start using move semantics more regularly, youâ€™ll start to find cases where you want to invoke move semantics, <code>but the objects you have to work with are l-values, not r-values</code>. Consider the following swap function as an example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>) &#123;</span> </span><br><span class="line">  T tmp &#123; a &#125;; <span class="comment">// invokes copy constructor</span></span><br><span class="line">  a = b; <span class="comment">// invokes copy assignment</span></span><br><span class="line">  b = tmp; <span class="comment">// invokes copy assignment</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> x&#123; <span class="string">"abc"</span> &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> y&#123; <span class="string">"de"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	swap(x, y);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As we showed last lesson, <code>making copies can be inefficient</code>. And this version of swap makes 3 copies. That leads to a lot of excessive string creation and destruction, which is slow.</p>
<p>However, doing copies isnâ€™t necessary here. All weâ€™re really trying to do is swap the values of a and b, which can be accomplished just as well <code>using 3 moves instead</code>! So if we switch from copy semantics to move semantics, we can make our code more performant.</p>
<p>But how? The problem here is that parameters a and b are l-value references, not r-value references, so we donâ€™t have a way to invoke the move constructor and move assignment operator instead of copy constructor and copy assignment. By default, we get the copy constructor and copy assignment behaviors. What are we to do?</p>
<p><strong>std::move</strong></p>
<p>In C++11, std::move is a standard library function that serves a single purpose â€” to convert its argument into an r-value. We can pass an l-value to std::move, and it will return an r-value reference. std::move is defined in the utility header.</p>
<p>Hereâ€™s the same program as above, but with a swap() function that uses std::move to convert our l-values into r-values so we can invoke move semantics:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>) &#123;</span></span><br><span class="line">  T tmp &#123; <span class="built_in">std</span>::move(a) &#125;; <span class="comment">// invokes move constructor</span></span><br><span class="line">  a = <span class="built_in">std</span>::move(b); <span class="comment">// invokes move assignment</span></span><br><span class="line">  b = <span class="built_in">std</span>::move(tmp); <span class="comment">// invokes move assignment</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> x&#123; <span class="string">"abc"</span> &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> y&#123; <span class="string">"de"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	swap(x, y);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Another example</strong></p>
<p>We can also use std::move when filling elements of a container, such as std::vector, with l-values.</p>
<p>In the following program, we first add an element to a vector using copy semantics. Then we add an element to the vector using move semantics.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Knock"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Copying str\n"</span>;</span><br><span class="line">	v.push_back(str); <span class="comment">// calls l-value version of push_back, which copies str into the array element</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"str: "</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vector: "</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nMoving str\n"</span>;</span><br><span class="line"> </span><br><span class="line">	v.push_back(<span class="built_in">std</span>::move(str)); <span class="comment">// calls r-value version of push_back, which moves str into the array element</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"str: "</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vector:"</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">' '</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Copying str</span></span><br><span class="line"><span class="comment">  str: Knock</span></span><br><span class="line"><span class="comment">  vector: Knock</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Moving str</span></span><br><span class="line"><span class="comment">  str:</span></span><br><span class="line"><span class="comment">  vector: Knock Knock</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>move æ–¹æ³•é»˜è®¤æ˜¯ copyï¼Œå¯èƒ½åªæ˜¯å¤šäº†ä¸€ä¸ªå°†åŽŸæ¥çš„å¯¹è±¡é”€æ¯æˆ–è€…æˆå‘˜è®¾ç½®ä¸º nullptrï¼Ÿ</p>
</blockquote>
<p>In the first case, we passed push_back() an l-value, so it used copy semantics to add an element to the vector. For this reason, the value in str is left alone.</p>
<p>In the second case, we passed push_back() an r-value (actually an l-value converted via std::move), so it used move semantics to add an element to the vector. This is more efficient, <code>as the vector element can steal the string&#39;s value rather than having to copy it. In this case, str is left empty</code>.</p>
<p>At this point, itâ€™s worth reiterating that std::move() <code>gives a hint to the compiler that the programmer doesn&#39;t need this object any more</code> (at least, not in its current state). Consequently, you should not use std::move() on any persistent object you donâ€™t want to modify, and you should not expect the state of any objects that have had std::move() applied to be the same after they are moved!</p>
<p>In the above example, string str is set to the empty string after being moved (which is what std::string always does after a successful move). This allows us to reuse variable str if we wish (or we can ignore it, if we no longer have a use for it).</p>
<p><strong>Where else is std::move useful?</strong></p>
<p>std::move can also be useful when sorting an array of elements. Many sorting algorithms (such as selection sort and bubble sort) work by swapping pairs of elements. In previous lessons, weâ€™ve had to resort to copy-semantics to do the swapping. Now we can use move semantics, which is more efficient.</p>
<p>It can also be useful if we want to move the contents managed by one smart pointer to another.</p>
<p><strong>Conclusion</strong></p>
<p>std::move can be used whenever we want to treat an l-value like an r-value for the purpose of invoking move semantics instead of copy semantics.</p>
<h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p>At the beginning of the chapter, we discussed how use of pointers can lead to bugs and memory leaks in some situations. For example, this can happen when a function early returns, or throws an exception, and the pointer is not properly deleted.</p>
<p>Smart pointers should never be dynamically allocated themselves (otherwise, there is the risk that the smart pointer may not be properly deallocated, which means the object it owns would not be deallocated, causing a memory leak). By always allocating smart pointers statically (as <code>local variables</code> or <code>composition members of a class</code>), weâ€™re guaranteed that the smart pointer will properly go out of scope when the function or object it is contained within ends, ensuring the object the smart pointer owns is properly deallocated.</p>
<p>C++11 standard library ships with 4 smart pointer classes: <code>std::auto_ptr</code> (which you shouldnâ€™t use â€” itâ€™s being removed in C++17), <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, and <code>std::weak_ptr</code>. std::unique_ptr is by far the most used smart pointer class, so weâ€™ll cover that one first. In the next lesson, weâ€™ll cover std::shared_ptr and std::weak_ptr.</p>
<p><strong>std::unique_ptr</strong></p>
<p>std::unique_ptr is the C++11 <code>replacement</code> for std::auto_ptr. <code>It should be used to manage any dynamically allocated object that is not shared by multiple objects.</code> That is, std::unique_ptr should completely own the object it manages, <code>not share that ownership with other classes</code>. std::unique_ptr lives in the <memory> header.</memory></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// allocate a Resource object and have it owned by std::unique_ptr</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res(<span class="keyword">new</span> Resource);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// res goes out of scope here, and the allocated Resource is destroyed</span></span><br></pre></td></tr></table></figure>
<p>Unlike std::auto_ptr, std::unique_ptr properly implements move semantics.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res1(<span class="keyword">new</span> Resource); <span class="comment">// Resource created here</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res2; <span class="comment">// Start as nullptr</span></span><br><span class="line"><span class="comment">// res2 = res1; // Won't compile: copy assignment is disabled</span></span><br><span class="line">res2 = <span class="built_in">std</span>::move(res1); <span class="comment">// res2 assumes ownership, res1 is set to null</span></span><br><span class="line"><span class="comment">// Ownership transferred</span></span><br><span class="line"><span class="comment">// sway the null value</span></span><br></pre></td></tr></table></figure>
<p><strong>Accessing the managed object</strong></p>
<p>std::unique_ptr has an overloaded <code>operator*</code> and <code>operator-&gt;</code> that can be used to return the resource being managed. </p>
<ul>
<li>Operator* returns a reference to the managed resource.</li>
<li>Operator-&gt; returns a pointer.</li>
</ul>
<p>Remember that std::unique_ptr may not always be managing an object â€” either because it was <code>created empty</code> (using the default constructor or passing in a nullptr as the parameter), or because the resource it was managing got moved to another std::unique_ptr. So before we use either of these operators, we should check whether the std::unique_ptr actually has a resource. Fortunately, this is easy: <code>std::unique_ptr has a cast to bool that returns true if the std::unique_ptr is managing a resource</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overload operator&lt;&lt;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res(<span class="keyword">new</span> Resource);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res) <span class="comment">// use implicit cast to bool to ensure res contains a Resource</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *res;  <span class="comment">// print the Resource that res is owning</span></span><br></pre></td></tr></table></figure>
<p><strong>std::unique_ptr and arrays</strong></p>
<p>Unlike std::auto_ptr, std::unique_ptr is smart enough to <code>know whether to use scalar delete or array delete</code>, so std::unique_ptr is okay to use with both scalar objects and arrays.</p>
<p>However, std::array or std::vector (or std::string) are almost always better choices than using std::unique_ptr with a fixed array, dynamic array, or C-style string.</p>
<p><strong>Rule:</strong> Favor std::array, std::vector, or std::string over a smart pointer managing a fixed array, dynamic array, or C-style string</p>
<p><strong>std::make_unique</strong></p>
<p>C++14 comes with an additional function named std::make_unique(). This templated function <code>constructs an object</code> of the template type and <code>initializes it with the arguments</code> passed into the function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fraction class</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Create a single dynamically allocated Fraction</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Fraction&gt; f1 = <span class="built_in">std</span>::make_unique&lt;Fraction&gt;(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *f1 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create a dynamically allocated array of Fractions of length 4</span></span><br><span class="line">	<span class="comment">// We can also use automatic type deduction to good effect here</span></span><br><span class="line">	<span class="keyword">auto</span> f2 = <span class="built_in">std</span>::make_unique&lt;Fraction[]&gt;(<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f2[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Use of std::make_unique() is optional, but is recommended over creating std::unique_ptr yourself.</code> This is because code using std::make_unique is simpler, and it also requires less typing (when used with automatic type deduction). Furthermore it resolves an exception safety issue that can result from C++ leaving the order of evaluation for function arguments unspecified.</p>
<p><strong>Rule:</strong> use std::make_unique() instead of creating std::unique_ptr and using new yourself.</p>
<p><strong>The exception safety issue in more detail</strong></p>
<p>For those wondering what the â€œexception safety issueâ€ mentioned above is, hereâ€™s a description of the issue.</p>
<p>Consider an expression like this one:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_function(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T), function_that_can_throw_exception());</span><br></pre></td></tr></table></figure>
<p>The compiler is given a lot of flexibility in terms of how it handles this call. It could create a new T, then call function_that_can_throw_exception(), then create the std::unique_ptr that manages the dynamically allocated T. If function_that_can_throw_exception() throws an exception, then the T that was allocated will not be deallocated, <code>because the smart pointer to do the deallocation hasn&#39;t been created yet</code>. This leads to T being leaked.</p>
<p>std::make_unique() doesnâ€™t suffer from this problem because the creation of the object T and the creation of the std::unique_ptr happen inside the std::make_unique() function, where thereâ€™s no ambiguity about order of execution.</p>
<p><strong>Returning std::unique_ptr from a function</strong></p>
<p>std::unique_ptr can be safely returned from a function by value:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; createResource() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;Resource&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; ptr = createResource();</span><br><span class="line">  <span class="comment">// do whatever</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the above code, createResource() returns a std::unique_ptr by value. <code>If this value is not assigned to anything, the temporary return value will go out of scope and the Resource will be cleaned up</code>. If it is assigned (as shown in main()), move semantics will be employed to <code>transfer</code> the Resource from the return value to the object assigned to (in the above example, ptr). This makes returning a resource by std::unique_ptr much safer than returning raw pointers!</p>
<p><code>In general, you should not return std::unique_ptr by pointer (ever) or reference (unless you have a specific compelling reason to).</code></p>
<p><strong>Passing std::unique_ptr to a function</strong></p>
<p>If you want the function to take ownership of the contents of the pointer, pass the std::unique_ptr by value. Note that because copy semantics have been disabled, youâ€™ll need to use std::move to actually pass the variable in.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">takeOwnership</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (res)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *res;</span><br><span class="line">&#125; <span class="comment">// the Resource is destroyed here</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_unique&lt;Resource&gt;();</span><br><span class="line">  <span class="comment">// takeOwnership(ptr);  // This doesn't work, need to use move semantics</span></span><br><span class="line">  takeOwnership(<span class="built_in">std</span>::move(ptr));  <span class="comment">// ok: use move semantics</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, most of the time, you wonâ€™t want the function to take ownership of the resource. Although you can pass a std::unique_ptr by reference (which will allow the function to use the object without assuming ownership), you should only do so when the caller might alter or change the object being managed.</p>
<p>Instead, <code>it&#39;s better to just pass the resource itself</code> (by pointer or reference, depending on whether null is a valid argument). This allows the function to remain agnostic of how the caller is managing its resources. To get a raw resource pointer from a std::unique_ptr, you can use the <code>get()</code> member function:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non-taking-ownership version</span></span><br><span class="line"><span class="comment">// The function only uses the resource, so we'll accept a pointer to the resource, not a reference to the whole std::unique_ptr&lt;Resource&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useResource</span><span class="params">(Resource *res)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_unique&lt;Resource&gt;();</span><br><span class="line">	useResource(ptr.get()); </span><br><span class="line">  <span class="comment">// note: get() used here to get a pointer to the Resource</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ending program\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The Resource is destroyed here</span></span><br></pre></td></tr></table></figure>
<p><strong>Misusing std::unique_ptr</strong></p>
<p>There are two easy ways to misuse std::unique_ptrs, both of which are easily avoided. </p>
<ul>
<li><p>First, donâ€™t let multiple classes manage the same resource. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource *res = <span class="keyword">new</span> Resource;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res1(res);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res2(res);</span><br></pre></td></tr></table></figure>
<p>While this is legal syntactically, the end result will be that both res1 and res2 will try to delete the Resource, which will lead to <code>undefined behavior</code>.</p>
</li>
<li><p>Second, donâ€™t manually delete the resource out from underneath the std::unique_ptr.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource *res = <span class="keyword">new</span> Resource;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res1(res);</span><br><span class="line"><span class="keyword">delete</span> res;</span><br></pre></td></tr></table></figure>
<p>If you do, the std::unique_ptr will try to delete an already deleted resource, again leading to <code>undefined behavior</code>.</p>
</li>
</ul>
<p><strong>Note that</strong> std::make_unique() prevents both of the above cases from happening inadvertently.</p>
<h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p>Unlike std::unique_ptr, which is designed to singly own and manage a resource, std::shared_ptr is meant to solve the case where you need <code>multiple smart pointers co-owning a resource</code>.</p>
<p>This means that it is fine to have multiple std::shared_ptr pointing to the same resource. <code>Internally</code>, std::shared_ptr keeps track of how many std::shared_ptr are sharing the resource. <code>As long as at least one std::shared_ptr is pointing to the resource, the resource will not be deallocated</code>, even if individual std::shared_ptr are destroyed. As soon as the last std::shared_ptr managing the resource goes out of scope (or is reassigned to point at something else), the resource will be deallocated.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// allocate a Resource object and have it owned by std::shared_ptr</span></span><br><span class="line">	Resource *res = <span class="keyword">new</span> Resource;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; ptr1(res);</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; ptr2(ptr1); <span class="comment">// use copy initialization to make another std::shared_ptr pointing to the same thing (depending on types)</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing one shared pointer\n"</span>;</span><br><span class="line">	&#125; <span class="comment">// ptr2 goes out of scope here, but nothing happens</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing another shared pointer\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// ptr1 goes out of scope here, and the allocated Resource is destroyed</span></span><br></pre></td></tr></table></figure>
<p><code>Note that we created a second shared pointer from the first shared pointer (using copy initialization)</code>. This is important. Consider the following similar program:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Resource *res = <span class="keyword">new</span> Resource;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; ptr1(res);</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; ptr2(res);</span><br><span class="line">    <span class="comment">// create ptr2 directly from res (instead of ptr1)</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing one shared pointer\n"</span>;</span><br><span class="line">	&#125; <span class="comment">// ptr2 goes out of scope here, and the allocated Resource is destroyed</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing another shared pointer\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// ptr1 goes out of scope here, and the allocated Resource is destroyed again</span></span><br></pre></td></tr></table></figure>
<p>and then crashes (at least on the authorâ€™s machine).</p>
<p>The difference here is that we created two std::shared_ptr independently from each other. As a consequence, even though theyâ€™re both pointing to the same Resource, <code>they aren&#39;t aware of each other</code>. When ptr2 goes out of scope, it thinks itâ€™s the only owner of the Resource, and deallocates it. When ptr1 later goes out of the scope, it thinks the same thing, and tries to delete the Resource again. Then bad things happen.</p>
<p>Fortunately, this is easily avoided by using copy assignment or copy initialization when you need multiple shared pointers pointing to the same Resource.</p>
<p><strong>Rule:</strong> Always make a copy of an existing std::shared_ptr if you need more than one std::shared_ptr pointing to the same resource.</p>
<p><strong>std::make_shared</strong></p>
<p>Much like std::make_unique() can be used to create a std::unique_ptr in C++14, std::make_shared() can (and should) be used to make a std::shared_ptr. std::make_shared() is available in C++11.</p>
<p>Hereâ€™s our original example, using std::make_shared():</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// allocate a Resource object and have it owned by std::shared_ptr</span></span><br><span class="line">	<span class="keyword">auto</span> ptr1 = <span class="built_in">std</span>::make_shared&lt;Resource&gt;();</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> ptr2 = ptr1; <span class="comment">// create ptr2 using copy initialization of ptr1</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing one shared pointer\n"</span>;</span><br><span class="line">	&#125; <span class="comment">// ptr2 goes out of scope here, but nothing happens</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing another shared pointer\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// ptr1 goes out of scope here, and the allocated Resource is destroyed</span></span><br></pre></td></tr></table></figure>
<p>std::make_shared() is simpler and safer (<code>there&#39;s no way to directly create two std::shared_ptr pointing to the same resource using this method</code>). However, std::make_shared() is also more performant than not using it. The reasons for this lie in the way that std::shared_ptr keeps track of how many pointers are pointing at a given resource.</p>
<p><strong>Digging into std::shared_ptr</strong></p>
<p>Unlike std::unique_ptr, which uses a single pointer internally, std::shared_ptr uses two pointers internally. One pointer points at the resource being managed. <code>The other points at a &quot;control block&quot;, which is a dynamically allocated object that tracks of a bunch of stuff, including how many std::shared_ptr are pointing at the resource.</code> When a std::shared_ptr is created via a std::shared_ptr constructor, the memory for the managed object (which is usually passed in) and control block (which the constructor creates) are allocated separately. However, when using std::make_shared(), this can be optimized into a single memory allocation, which leads to better performance.</p>
<p>This also explains why independently creating two std::shared_ptr pointed to the same resource gets us into trouble. Each std::shared_ptr will have one pointer pointing at the resource. However, <code>each std::shared_ptr will independently allocate its own control block</code>, which will indicate that it is the only pointer owning that resource. Thus, when that std::shared_ptr goes out of scope, it will deallocate the resource, not realizing there are other std::shared_ptr also trying to manage that resource.</p>
<p>However, when a std::shared_ptr is cloned using copy assignment, <code>the data in the control block can be appropriately updated</code> to indicate that there are now additional std::shared_ptr co-managing the resource.</p>
<p><strong>Shared pointers can be created from unique pointers</strong></p>
<p>A std::unique_ptr can be converted into a std::shared_ptr via a special std::shared_ptr constructor that accepts a std::unique_ptr r-value. <code>The contents of the std::unique_ptr will be moved to the std::shared_ptr</code>.</p>
<p>However, <code>std::shared_ptr can not be safely converted to a std::unique_ptr</code>. This means that if youâ€™re creating a function that is going to return a smart pointer, <code>you&#39;re better off returning a std::unique_ptr and assigning it to a std::shared_ptr if and when that&#39;s appropriate</code>.</p>
<p><strong>The perils of std::shared_ptr</strong></p>
<p>std::shared_ptr has some of the same challenges as std::unique_ptr â€” if the std::shared_ptr is not properly disposed of (either because it was dynamically allocated and never deleted, or it was part of an object that was dynamically allocated and never deleted) then the resource it is managing wonâ€™t be deallocated either. With std::unique_ptr, you only have to worry about one smart pointer being properly disposed of. With std::shared_ptr, you have to worry about them all. <code>If any of the std::shared_ptr managing a resource are not properly destroyed, the resource will not be deallocated properly.</code></p>
<p><strong>std::shared_ptr and arrays</strong></p>
<p>In C++14 and earlier, std::shared_ptr does not have proper support for managing arrays, and should not be used to manage a C-style array. As of C++17, std::shared_ptr does have support for arrays. However, as of C++17, std::make_shared is still lacking proper support for arrays, and should not be used to create shared arrays. This will likely be addressed in C++20.</p>
<h3 id="Circular-dependency-issues-with-std-shared-ptr-and-std-weak-ptr"><a href="#Circular-dependency-issues-with-std-shared-ptr-and-std-weak-ptr" class="headerlink" title="Circular dependency issues with std::shared_ptr, and std::weak_ptr"></a>Circular dependency issues with std::shared_ptr, and std::weak_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">partnerUp</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p1, </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!p1 || !p2)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">		p1-&gt;m_partner = p2;</span><br><span class="line">		p2-&gt;m_partner = p1;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1-&gt;m_name &lt;&lt; <span class="string">" is now partnered with "</span> &lt;&lt; p2-&gt;m_name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> lucy = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Lucy"</span>); <span class="comment">// create a Person named "Lucy"</span></span><br><span class="line">	<span class="keyword">auto</span> ricky = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Ricky"</span>); <span class="comment">// create a Person named "Ricky"</span></span><br><span class="line"> </span><br><span class="line">	partnerUp(lucy, ricky); <span class="comment">// Make "Lucy" point to "Ricky" and vice-versa</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And thatâ€™s it. No deallocations took place. Uh. oh. What happened?</p>
<p>It turns out that this can happen any time shared pointers form a circular reference.</p>
<p><strong>Circular references</strong></p>
<p>A Circular reference (also called a cyclical reference or a cycle) is a series of references where each object references the next, and the last object references back to the first, causing a referential loop. The references do not need to be actual C++ references â€” they can be pointers, unique IDs, or any other means of identifying specific objects.</p>
<p>In the context of shared pointers, the references will be pointers.</p>
<p><strong>A reductive case</strong></p>
<p>It turns out, this cyclical reference issue can <code>even happen with a single std::shared_ptr</code> â€” a std::shared_ptr referencing the object that contains it is still a cycle (just a reductive one). Although itâ€™s fairly unlikely that this would ever happen in practice, weâ€™ll show you for additional comprehension:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; m_ptr; <span class="comment">// initially created empty</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ptr1 = <span class="built_in">std</span>::make_shared&lt;Resource&gt;();</span><br><span class="line">	ptr1-&gt;m_ptr = ptr1; <span class="comment">// m_ptr is now sharing the Resource that contains it</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>So what is std::weak_ptr for anyway?</strong></p>
<p>std::weak_ptr was designed to solve the â€œcyclical ownershipâ€ problem described above. <code>A std::weak_ptr is an observer</code> â€” it can observe and access the same object as a std::shared_ptr (or other std::weak_ptrs) but it is not considered an owner. Remember, when a std::shared pointer goes out of scope, it only considers whether other std::shared_ptr are co-owning the object. std::weak_ptr does not count!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">  <span class="built_in">std</span>::weak_ptr&lt;Person&gt; m_partnet;</span><br><span class="line">  <span class="comment">//  note: This is now a std::weak_ptr</span></span><br><span class="line">  <span class="comment">// same code below</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Using std::weak_ptr</strong></p>
<p><code>The downside of std::weak_ptr is that std::weak_ptr are not directly usable (they have no operator-&gt;). To use a std::weak_ptr, you must first convert it into a std::shared_ptr.</code> Then you can use the std::shared_ptr. To convert a std::weak_ptr into a std::shared_ptr, you can use the lock() member function. Hereâ€™s the above example, updated to show this off:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; getPartner() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> m_partner.lock(); <span class="comment">// use lock() to convert weak_ptr to shared_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// in main:</span></span><br><span class="line"><span class="keyword">auto</span> partnet = ricky-&gt;getPartner();</span><br></pre></td></tr></table></figure>
<p>We donâ€™t have to worry about circular dependencies with std::shared_ptr variable â€œpartnerâ€ <code>since it&#39;s just a local variable inside the function</code>. It will eventually go out of scope at the end of the function and the reference count will be decremented by 1.</p>

        
      </div>
      
      
      
    </div>
    
    
    
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/cat_with_glasses.jpg" alt="Junhao Wang">
            
              <p class="site-author-name" itemprop="name">Junhao Wang</p>
              <p class="site-description motion-element" itemprop="description">Debug the old world, bug the new world!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">118</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/chuckwangg" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i>Facebook</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/junhaowww" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.linkedin.com/in/junhaowww/" target="_blank" title="LinkedIn">
                      
                        <i class="fa fa-fw fa-linkedin"></i>LinkedIn</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/maodai/" target="_blank" title="è±†ç“£ (Book)">
                      
                        <i class="fa fa-fw fa-book"></i>è±†ç“£ (Book)</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.jianshu.com/u/41865efdad5d/" title="Xiaofud" target="_blank">Xiaofud</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.davex.pw/" title="DaveX" target="_blank">DaveX</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://alexfan.xyz/" title="alexfan.xyz" target="_blank">alexfan.xyz</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Exceptions"><span class="nav-number">1.</span> <span class="nav-text">Exceptions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-exception-handling"><span class="nav-number">1.1.</span> <span class="nav-text">Basic exception handling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exceptions-functions-and-stack-unwinding"><span class="nav-number">1.2.</span> <span class="nav-text">Exceptions, functions, and stack unwinding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Uncaught-exceptions-catch-all-handlers-and-exception-specifiers"><span class="nav-number">1.3.</span> <span class="nav-text">Uncaught exceptions, catch-all handlers, and exception specifiers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exceptions-classes-and-inheritance"><span class="nav-number">1.4.</span> <span class="nav-text">Exceptions, classes, and inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rethrowing-exceptions"><span class="nav-number">1.5.</span> <span class="nav-text">Rethrowing exceptions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-try-blocks"><span class="nav-number">1.6.</span> <span class="nav-text">Function try blocks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception-dangers-and-downsides"><span class="nav-number">1.7.</span> <span class="nav-text">Exception dangers and downsides</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Move-semantics-and-smart-pointers"><span class="nav-number">2.</span> <span class="nav-text">Move semantics and smart pointers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#R-value-reference"><span class="nav-number">2.1.</span> <span class="nav-text">R-value reference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Move-constructors-and-move-assignment"><span class="nav-number">2.2.</span> <span class="nav-text">Move constructors and move assignment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-move"><span class="nav-number">2.3.</span> <span class="nav-text">std::move</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-unique-ptr"><span class="nav-number">2.4.</span> <span class="nav-text">std::unique_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-shared-ptr"><span class="nav-number">2.5.</span> <span class="nav-text">std::shared_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Circular-dependency-issues-with-std-shared-ptr-and-std-weak-ptr"><span class="nav-number">2.6.</span> <span class="nav-text">Circular dependency issues with std::shared_ptr, and std::weak_ptr</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junhao Wang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://junhaow.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.junhaow.com/studynotes/cpp/learncpp/Study Notes on LearnCpp Part 6.html';
          this.page.identifier = 'studynotes/cpp/learncpp/Study Notes on LearnCpp Part 6.html';
          this.page.title = 'Study Notes on LearnCpp (Part 6 - Exceptions, Smart Pointers)';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://junhaow.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  

  
  


  

  


</body>
</html>
