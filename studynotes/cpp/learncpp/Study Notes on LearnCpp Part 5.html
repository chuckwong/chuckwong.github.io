<!DOCTYPE html>




<html class="theme-next pisces" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,300italic,400,400italic,700,700italic|Bitter:300,300italic,400,400italic,700,700italic|Bitter:300,300italic,400,400italic,700,700italic|Menlo:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="junhaow, maodai">










<meta name="description" content="Source: LearnCpp.com by Alex Virtual FunctionsPointers and references to the base class of derived objects12345Derived derived(5);// These are both legal!Base &amp;amp;rBase = derived;Base *pBase = &amp;amp;">
<meta property="og:type" content="website">
<meta property="og:title" content="Study Notes on LearnCpp (Part 5 - Virtual Functions, Templates)">
<meta property="og:url" content="http://www.junhaow.com/studynotes/cpp/learncpp/Study Notes on LearnCpp Part 5.html">
<meta property="og:site_name" content="B_L_OO_GGG">
<meta property="og:description" content="Source: LearnCpp.com by Alex Virtual FunctionsPointers and references to the base class of derived objects12345Derived derived(5);// These are both legal!Base &amp;amp;rBase = derived;Base *pBase = &amp;amp;">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/42h87.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/87krl.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/eu22x.jpg">
<meta property="og:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/usjnr.jpg">
<meta property="og:updated_time" content="2020-02-06T10:31:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Study Notes on LearnCpp (Part 5 - Virtual Functions, Templates)">
<meta name="twitter:description" content="Source: LearnCpp.com by Alex Virtual FunctionsPointers and references to the base class of derived objects12345Derived derived(5);// These are both legal!Base &amp;amp;rBase = derived;Base *pBase = &amp;amp;">
<meta name="twitter:image" content="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/42h87.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.junhaow.com/studynotes/cpp/learncpp/Study Notes on LearnCpp Part 5.html">





  <title>Study Notes on LearnCpp (Part 5 - Virtual Functions, Templates) | B_L_OO_GGG</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-146643833-1', 'auto');
  ga('send', 'pageview');
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->





</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">


  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">B_L_OO_GGG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Sumomo mo momo mo no uchi</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home


            

            

            

            

            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-inbox"></i> <br>
            
            Archives


            

            
              <span class="badge">50</span>
            

            

            

            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-studynotes">
          <a href="/studynotes/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-pencil"></i> <br>
            
            Study Notes


            

            

            
              <span class="badge">6</span>
            

            

            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-lc">
          <a href="/lc/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            LeetCode Book


            

            

            

            
              <span class="badge badge-lc">251 / ‚àû</span>
            

            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-games">
          <a href="/games/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-gamepad"></i> <br>
            
            Games I've Played


            

            

            

            

            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-address-card"></i> <br>
            
            About Me


            

            

            

            

            
              <span class="badge-about">üëã</span>
            

          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

	<h1 class="post-title" itemprop="name headline">Study Notes on LearnCpp (Part 5 - Virtual Functions, Templates)</h1>



</header>

      
      
      
      <div class="post-body">
        
        
          <p><br></p>
<p>Source: <a href="https://www.learncpp.com/" target="_blank" rel="noopener">LearnCpp.com</a> by Alex</p>
<h2 id="Virtual-Functions"><a href="#Virtual-Functions" class="headerlink" title="Virtual Functions"></a>Virtual Functions</h2><h3 id="Pointers-and-references-to-the-base-class-of-derived-objects"><a href="#Pointers-and-references-to-the-base-class-of-derived-objects" class="headerlink" title="Pointers and references to the base class of derived objects"></a>Pointers and references to the base class of derived objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These are both legal!</span></span><br><span class="line">Base &amp;rBase = derived;</span><br><span class="line">Base *pBase = &amp;derived;</span><br></pre></td></tr></table></figure>
<p>It turns out that because rBase and pBase are a Base reference and pointer, <strong>they can only see members of Base</strong> (or any classes that Base inherited). So even though <code>Derived::getName()</code> shadows (hides) <code>Base::getName()</code> for Derived objects, the Base pointer/reference cannot see <code>Derived::getName()</code>. Consequently, they call <code>Base::getName()</code>, which is why rBase and pBase report that they are a Base rather than a Derived.</p>
<p><strong>Note:</strong> this also means it is not possible to call <code>Derived::getValueDoubled()</code> using rBase or pBase. They are unable to see anything in Derived.</p>
<p>Want to take a guess what virtual functions are for? :) hhh</p>
<h3 id="Virtual-functions-and-polymorphism"><a href="#Virtual-functions-and-polymorphism" class="headerlink" title="Virtual functions and polymorphism"></a>Virtual functions and polymorphism</h3><p>A <code>virtual function</code> is a special type of function that, when called, <strong>resolves to the most-derived version of the function</strong> that exists between the base and derived class. This capability is known as <code>polymorphism</code>. A derived function is considered a match if it has the same signature (name, parameter types, and <strong>whether it is const</strong>) and return type as the base version of the function. Such functions are called <code>overrides</code>.</p>
<p>To make a function virtual, simply place the ‚Äúvirtual‚Äù keyword before the function declaration.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125; <span class="comment">// note addition of virtual keyword</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derived derived;</span><br><span class="line">  Base &amp;rBase = derived;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="comment">// output: rBase is a Derived</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because rBase is a reference to the Base portion of a Derived object, when <code>rBase.getName()</code> is evaluated, it would normally resolve to <code>Base::getName()</code>. However, <code>Base::getName()</code> is virtual, <strong>which tells the program to go look and see if there are any more-derived versions of the function available between Base and Derived</strong>. In this case, it will resolve to <code>Derived::getName()</code>.</p>
<p><strong>A word of warning:</strong> the signature of the derived class function must exactly match the signature of the base class virtual function in order for the derived class function to be used. If the derived class function has different parameter types, the program will likely still compile fine, but the virtual function will not resolve as intended.</p>
<p><strong>Use of the virtual keyword</strong></p>
<p><strong>If a function is marked as virtual, all matching overrides are also considered virtual</strong>, even if they are not explicitly marked as such. However, <strong>having the keyword virtual on the derived functions does not hurt, and it serves as a <code>useful reminder</code></strong> that the function is a virtual function rather than a normal one. Consequently, it‚Äôs generally a good idea to use the virtual keyword for virtualized functions in derived classes even though it‚Äôs not strictly necessary.</p>
<p><strong>Note that:</strong> return types must be matched either.</p>
<p><strong>Do not call virtual functions from constructors or destructors</strong></p>
<p>Here‚Äôs another gotcha that often catches unsuspecting new programmers. You should not call virtual functions from constructors or destructors. Why?</p>
<p>Remember that when a Derived class is created, the Base portion is constructed first. If you were to call a virtual function from the Base constructor, and <strong>Derived portion of the class hadn‚Äôt even been created yet</strong>, it would be unable to call the Derived version of the function because there‚Äôs no Derived object for the Derived function to work on. In C++, it will call the Base version instead.</p>
<p>A similar issue exists for destructors. If you call a virtual function in a Base class destructor, it will always resolve to the Base class version of the function, because the Derived portion of the class will already have been destroyed.</p>
<p><strong>Rule:</strong> Never call virtual functions from constructors or destructors</p>
<p><strong>The downside of virtual functions</strong></p>
<p>Since most of the time you‚Äôll want your functions to be virtual, why not just make all functions virtual? The answer is because it‚Äôs <code>inefficient</code> ‚Äî resolving a virtual function call takes longer than resolving a regular one. Furthermore, <strong>the compiler also has to allocate an extra pointer for each class object that has one or more virtual functions.</strong> We‚Äôll talk about this more in future lessons in this chapter.</p>
<h3 id="The-override-and-final-specifiers-and-covariant-return-types"><a href="#The-override-and-final-specifiers-and-covariant-return-types" class="headerlink" title="The override and final specifiers, and covariant return types"></a>The override and final specifiers, and covariant return types</h3><p>To address some common challenges with inheritance, C++11 added two <code>special identifiers</code> to C++: <code>override</code> and <code>final</code>. Note that these identifiers are <strong>not considered keywords</strong> ‚Äî they are normal identifiers that have special meaning in certain contexts.</p>
<p>Although final isn‚Äôt used very much, override is a fantastic addition that you should use regularly. In this lesson, we‚Äôll take a look at both, as well as one exception to the rule that virtual function override return types must match.</p>
<p>Consider the following example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">  <span class="comment">// note: parameter is a short int</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">  <span class="comment">// note: function is const</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  A &amp;rBase = b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName1(<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// output A</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName2(<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// output A</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this particular case, because A and B just print their names, it‚Äôs fairly easy to see that we messed up our overrides, and that the wrong virtual function is being called. However, in a more complicated program, where the functions have behaviors or return values that aren‚Äôt printed, such issues can be very difficult to debug.</p>
<p>To help address the issue of functions that are meant to be overrides but aren‚Äôt, C++11 introduced the <code>override specifier</code>. Override can be applied to any override function by placing the specifier <strong>in the same place const would go</strong>. If the function does not override a base class function, the compiler will flag the function as an error.</p>
<p>Like <code>@Override</code> in Java!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> x)</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">  <span class="comment">// compile error, function is not an override</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">  <span class="comment">// compile error, function is not an override</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">  <span class="comment">// okay, function is an override of A::getName2(int)</span></span><br></pre></td></tr></table></figure>
<p><strong>There is no performance penalty</strong> for using the override specifier, and it helps avoid inadvertent errors. Consequently, we highly recommend using it for every virtual function override you write to ensure you‚Äôve actually overridden the function you think you have.</p>
<p><strong>Rule:</strong> Apply the override specifier to every intended override function you write.</p>
<p><strong>The final specifier</strong></p>
<p>There may be cases where you don‚Äôt want someone to be able to override a virtual function, or inherit from a class. The final specifier can be used to tell the compiler to enforce this. If the user tries to override a function or class that has been specified as final, the compiler will give a compile error.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class A</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line"><span class="comment">// class B</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override final </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line"><span class="comment">// class C - compile error</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>In the case where we want to <strong>prevent inheriting from a class</strong>, the final specifier is applied after the class name:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">final</span> :</span> <span class="keyword">public</span> A &#123; <span class="comment">// note use of final specifier here</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123; <span class="comment">// compile error: cannot inherit from final class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Covariant return type</strong></p>
<p>There is one special case in which a derived class virtual function override can have a different return type than the base class and still be considered a matching override. If the return type of a virtual function is a pointer or a reference to a class, override functions can return a pointer or a reference to a derived class. These are called covariant return types. Here is an example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// This version of getThis() returns a pointer to a Base class</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Base* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"called Base::getThis()\n"</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"returned a Base\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Normally override functions have to return objects of the same type as the base function</span></span><br><span class="line">  <span class="comment">// However, because Derived is derived from Base, it's okay to return Derived* instead of Base*</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"called Derived::getThis()\n"</span>;  <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"returned a Derived\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derived d;</span><br><span class="line">  Base *b = &amp;d;</span><br><span class="line">  d.getThis()-&gt;printType();   <span class="comment">// calls Derived::getThis(), returns a Derived*, calls Derived::printType</span></span><br><span class="line">  b-&gt;getThis()-&gt;printType();  <span class="comment">// calls Derived::getThis(), returns a Base*, calls Base::printType</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// output</span></span><br><span class="line">  <span class="comment">// called Derived::getThis()</span></span><br><span class="line">  <span class="comment">// returned a Derived</span></span><br><span class="line">  <span class="comment">// called Derived::getThis()</span></span><br><span class="line">  <span class="comment">// returned a Base</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> some older compilers (e.g. Visual Studio 6) do not support covariant return types.</p>
<p>One interesting note about covariant return types: C++ can‚Äôt dynamically select types, so you‚Äôll always get the type that matches the base version of the function being called.</p>
<p>In the above example, we first call <code>d.getThis()</code>. Since d is a Derived, this calls <code>Derived::getThis()</code>, which returns a <code>Derived*</code>. This <code>Derived*</code> is then used to call non-virtual function <code>Derived::printType()</code>.</p>
<p>Now the interesting case. We then call <code>b-&gt;getThis()</code>. Variable b is a Base pointer to a Derived object. <code>Base::getThis()</code> is virtual function, so this calls <code>Derived::getThis()</code>. Although <code>Derived::getThis()</code> returns a <code>Derived*</code>, because base version of the function returns a <code>Base*</code>, the returned <code>Derived*</code> is upcast to a <code>Base*</code>. And thus, <code>Base::printType()</code> is called.</p>
<p>In other words, in the above example, you only get a <code>Derived*</code> if you call <code>getThis()</code> with an object that is typed as a Derived object in the first place. (6^6)</p>
<h3 id="Virtual-destructors-virtual-assignment-and-overriding-virtualization"><a href="#Virtual-destructors-virtual-assignment-and-overriding-virtualization" class="headerlink" title="Virtual destructors, virtual assignment, and overriding virtualization"></a>Virtual destructors, virtual assignment, and overriding virtualization</h3><p>Although C++ provides a default destructor for your classes if you do not provide one yourself, it is sometimes the case that you will want to provide your own destructor (particularly if the class needs to deallocate memory). You should <strong>always</strong> make your destructors virtual if you‚Äôre dealing with inheritance. Consider the following example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Base</span></span><br><span class="line"><span class="comment">// ~Base (not virtual)</span></span><br><span class="line"><span class="comment">// class Derived</span></span><br><span class="line"><span class="comment">// ~Derived (not virtual)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derived *derived = <span class="keyword">new</span> Derived(<span class="number">5</span>);</span><br><span class="line">  Base *base = derived;</span><br><span class="line">  <span class="keyword">delete</span> base; <span class="comment">// it will call the Base destructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, we really want the delete function to call Derived‚Äôs destructor (<strong>which will call Base‚Äôs destructor in turn</strong>), otherwise <code>m_array</code> will not be deleted. We do this by making Base‚Äôs destructor virtual:</p>
<p>Using virtual:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Base() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Calling ~Base() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> *m_array;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Derived(<span class="keyword">int</span> length) &#123;</span><br><span class="line">    m_array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~Dervied() &#123; <span class="comment">// note: virtual</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Calling ~Derived() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] m_array;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">Calling ~Derived()</span><br><span class="line">Calling ~Base()</span><br></pre></td></tr></table></figure>
<p><strong>Rule:</strong> Whenever you are dealing with inheritance, you should make any explicit destructors virtual.</p>
<p><strong>Virtual assignment</strong></p>
<p>It is possible to make the assignment operator virtual. However, unlike the destructor case where virtualization is always a good idea, virtualizing the assignment operator really opens up a bag full of worms and gets into some advanced topics outside of the scope of this tutorial. Consequently, we are going to recommend you leave your assignments non-virtual for now, in the interest of simplicity.</p>
<p><strong>Ignoring virtualization</strong></p>
<p>Very rarely you may want to ignore the virtualization of a function. For example, consider the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>There may be cases where you want a Base pointer to a Derived object to call <code>Base::getName()</code> instead of <code>Derived::getName()</code>. To do so, simply use the scope resolution operator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derived derived;</span><br><span class="line">  Base &amp;base = derived;</span><br><span class="line">  <span class="comment">// Calls Base::getName() instead of the virtualized Derived::getName()</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; base.Base::getName() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Should we make all destructors virtual</strong></p>
<p><a href="https://www.learncpp.com/cpp-tutorial/123-virtual-destructors-virtual-assignment-and-overriding-virtualization/" target="_blank" rel="noopener">More</a></p>
<p>Two recommendations are as follows:</p>
<ul>
<li>If you intend your class to be inherited from, make sure your destructor is virtual.</li>
<li>If you do not intend your class to be inherited from, mark your class as final. This will prevent other classes from inheriting from it in the first place, without imposing any other use restrictions on the class itself.</li>
</ul>
<h3 id="Early-binding-and-late-binding"><a href="#Early-binding-and-late-binding" class="headerlink" title="Early binding and late binding"></a>Early binding and late binding</h3><p><strong>Binding</strong> refers to the process that is used to convert <code>identifiers</code> (such as variable and function names) into <code>addresses</code>. Although binding is used for both variables and functions, in this lesson we‚Äôre going to focus on function binding. (identifiers == symbols?)</p>
<p>Most of the function calls that the compiler encounters will be <code>direct function calls</code>. A direct function call is a statement that directly calls a function. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printValue(<span class="number">5</span>); <span class="comment">// This is a direct function call</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Direct function calls can be resolved using a process known as <code>early binding</code>. Early binding (also called <code>static binding</code>) means the compiler (or linker I think it should be the linker) is able to directly associate the identifier name (such as a function or variable name) with a <code>machine address</code>. Remember that all functions have a unique address. So when the compiler (or linker) encounters a function call, it replaces the function call with a machine language instruction that tells the CPU to jump to the address of the function.</p>
<p><strong>Late Binding</strong></p>
<p>In some programs, it is not possible to know which function will be called until runtime (when the program is run). This is known as <code>late binding</code> (or <code>dynamic binding</code>). In C++, one way to get late binding is to use <code>function pointers</code>. The function that a function pointer points to can be called by using the function call operator (<code>()</code>) on the pointer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> (*pFun)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pFun(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The compiler is unable to use <code>early binding</code> to resolve the function call <code>pFcn(x, y)</code> because it cannot tell which function <code>pFcn</code> will be pointing to at compile time!</p>
<p>Late binding is slightly less efficient since it involves an extra level of indirection. </p>
<ul>
<li>With early binding, the CPU can jump directly to the function‚Äôs address. </li>
<li>With late binding, the program has to read the address held in the pointer and then jump to that address. <strong>This involves one extra step, making it slightly slower.</strong> However, the advantage of late binding is that it is more flexible than early binding, because decisions about what function to call do not need to be made until run time.</li>
</ul>
<h3 id="The-virtual-table"><a href="#The-virtual-table" class="headerlink" title="The virtual table"></a>The virtual table</h3><p>To implement virtual functions, C++ uses a special form of late binding known as the <code>virtual table</code>. The virtual table is a lookup table of functions used to resolve function calls in a dynamic/late binding manner. The virtual table sometimes goes by other names, such as <code>vtable</code>, <code>virtual function table</code>, <code>virtual method table</code>, or <code>dispatch table</code>.</p>
<p>First, every class that uses virtual functions (or is derived from a class that uses virtual functions) is given its <code>own</code> virtual table. This table is simply a <code>static array</code> that the compiler sets up at compile time. <strong>A virtual table contains one entry for each virtual function that can be called by objects of the class</strong>. Each entry in this table is simply a <code>function pointer</code> that points to the<code>most-derived</code> function accessible by that class.</p>
<p>(markdown syntax compromise: *__vptr -&gt; VP)</p>
<p>Second, the compiler also adds a <code>hidden pointer</code> to the base class, which we will call <code>VP</code>. <code>VP</code> is set (automatically) when a class instance is created so that <strong>it points to the virtual table for that class</strong>. Unlike the *this pointer, which is actually a function parameter used by the compiler to resolve self-references, <code>VP</code> is a real pointer. Consequently, it makes each class object allocated bigger by the size of one pointer. It also means that <code>VP</code> is inherited by derived classes, which is important.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  FunctionPointer *__vptr;  <span class="comment">// the compiler set automatically</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Because there are 3 classes here, the compiler will set up 3 virtual tables: one for Base, one for D1, and one for D2. The compiler also adds a hidden pointer to the most base class that uses virtual functions.</p>
<p>When a class object is created, <code>VP</code> is set to point to the virtual table for that class. For example, when a object of type Base is created, <code>VP</code> is set to point to the virtual table for Base. When objects of type D1 or D2 are constructed, <code>VP</code> is set to point to the virtual table for D1 or D2 respectively (<code>VP</code> is inherited by Base class).</p>
<p>Now, let‚Äôs talk about how these virtual tables are filled out. Because there are only two virtual functions here, each virtual table will have two entries (one for function1(), and one for function2()). Remember that when these virtual tables are filled out, each entry is filled out with the most-derived function an object of that class type can call.</p>
<p>The virtual table for Base objects is simple. An object of type Base can only access the members of Base. Base has no access to D1 or D2 functions. Consequently, the entry for function1 points to Base::function1(), and the entry for function2 points to Base::function2().</p>
<p>The virtual table for D1 is slightly more complex. An object of type D1 can access members of both D1 and Base. However, D1 has overridden function1(), making D1::function1() more derived than Base::function1(). Consequently, the entry for function1 points to D1::function1(). D1 hasn‚Äôt overridden function2(), so the entry for function2 will point to Base::function2().</p>
<p>The virtual table for D2 is similar to D1, <strong>except the entry for function1 points to Base::function1()</strong> (because D2 does not override the function), and the entry for function2 points to D2::function2().</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/42h87.jpg" alt="" title="No Pic Say J8"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D1 d1;</span><br><span class="line">Base *dPtr = &amp;d1;</span><br></pre></td></tr></table></figure>
<p>Note that because dPtr is a base pointer, it only points to the Base portion of d1. However, also note that <code>VP</code> is in the Base portion of the class, so dPtr has access to this pointer. Finally, <strong>note that dPtr-&gt;<strong>vptr points to the D1 virtual table! Consequently, even though dPtr is of type Base, it still has access to D1‚Äôs virtual table (through </strong>vptr)</strong>.</p>
<p><strong>What happens if we call dPtr-&gt;function1()?</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D1 d1;</span><br><span class="line">Base *dPtr = &amp;d1;</span><br><span class="line">dPtr-&gt;function1();</span><br></pre></td></tr></table></figure>
<ul>
<li>First, the program recognizes that function1() is a virtual function. </li>
<li>Second, the program uses dPtr-&gt;__vptr to get to D1‚Äôs virtual table. </li>
<li>Third, it looks up which version of function1() to call in D1‚Äôs virtual table. This has been set to D1::function1(). Therefore, dPtr-&gt;function1() resolves to D1::function1()!</li>
</ul>
<p>By using these tables, the compiler and program are able to ensure function calls resolve to the appropriate virtual function, even if you‚Äôre only using a pointer or reference to a base class!</p>
<p><strong>Why slower?</strong></p>
<p>Calling a virtual function is slower than calling a non-virtual function for a couple of reasons: </p>
<ul>
<li>First, we have to use the *__vptr to get to the appropriate virtual table. </li>
<li>Second, we have to index the virtual table to find the correct function to call. Only then can we call the function. </li>
<li>As a result, we have to do 3 operations to find the function to call, as opposed to 2 operations for a normal indirect function call, or one operation for a direct function call. However, with modern computers, this added time is usually fairly insignificant.</li>
</ul>
<h3 id="Pure-virtual-functions-abstract-base-classes-and-interface-classes"><a href="#Pure-virtual-functions-abstract-base-classes-and-interface-classes" class="headerlink" title="Pure virtual functions, abstract base classes, and interface classes"></a>Pure virtual functions, abstract base classes, and interface classes</h3><p>C++ allows you to create a special kind of virtual function called a <code>pure virtual function</code> (or <code>abstract function</code>) that has no body at all! A pure virtual function simply acts as a placeholder that is meant to be redefined by derived classes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">sayHi</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Hi"</span>; &#125; <span class="comment">// a normal non-virtual function    </span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125; <span class="comment">// a normal virtual function</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// a pure virtual function</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// Compile error: cannot set non-virtual functions to 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>When we add a pure virtual function to our class, we are effectively saying, <strong>it is up to the derived classes to implement this function</strong>.</p>
<p>Using a pure virtual function has two main consequences: </p>
<ul>
<li>First, any class with <strong>one or more pure virtual functions</strong> becomes an <code>abstract base class</code>, which means that it cannot be instantiated!</li>
<li>Second, any derived class <strong>must define a body for this function</strong>, or that derived class will be considered an abstract base class as well.</li>
</ul>
<p>Also, by making constructor <code>protected</code>, we don‚Äôt want people creating Base objects directly; but we still want derived classes to be able to use it.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">  Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name) : m_name(name) &#123;</span><br><span class="line">    <span class="comment">// protected</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// but note that we can still add a body for speak</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* Animal::speak() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"buzz"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Cow(<span class="built_in">std</span>::<span class="built_in">string</span> name) : Animal(name) &#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Moo"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>When providing a body for a pure virtual function, the body must be provided separately (not inline).</strong> This paradigm can be useful when you want your base class to provide a <code>default implementation</code> for a function, but still force any derived classes to provide their own implementation. However, if the derived class is happy with the default implementation provided by the base class, it can simply call the base class implementation directly. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Animal::speak();</span><br><span class="line">  <span class="comment">// actually, it is this-&gt;Animal::speak()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Interface classes</strong></p>
<p>An interface class is a class that has <code>no member variables</code>, and where all of the functions are <code>pure virtual</code>! In other words, the class is purely a definition, and has no actual implementation. <strong>Interfaces are useful when you want to define the functionality that derived classes must implement</strong>, but leave the details of how the derived class implements that functionality entirely up to the derived class.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IErrorLog</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">openLog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">closeLog</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">writeError</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *errorMessage)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~IErrorLog() &#123;&#125; <span class="comment">// make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called</span></span><br><span class="line">  <span class="comment">// Any class inheriting from IErrorLog must provide implementations for all three functions in order to be instantiated.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Because interfaces have no data and no function bodies, they avoid a lot of the traditional problems with multiple inheritance while still providing much of the flexibility.</p>
<p><strong>Pure virtual functions and the virtual table</strong></p>
<p>Abstract classes still have virtual tables, as these can still be used if you have a pointer or reference to the abstract class. <strong>The virtual table entry for a pure virtual function will generally either contain a <code>null pointer</code></strong>, or point to a generic function that prints an error (sometimes this function is named __purecall) if no override is provided.</p>
<h3 id="Virtual-base-classes"><a href="#Virtual-base-classes" class="headerlink" title="Virtual base classes"></a>Virtual base classes</h3><p><strong>Diamond Problem (Multi-inheritance)</strong></p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/87krl.jpg" alt="" title="Diamond Problem"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PoweredDevice(<span class="keyword">int</span> power) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PoweredDevice: "</span> &lt;&lt; power &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span> :</span> <span class="keyword">public</span> PoweredDevice &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Scanner(<span class="keyword">int</span> scanner, <span class="keyword">int</span> power) : PoweredDevice(power) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Scanner: "</span> &lt;&lt; <span class="string">"scanner"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> :</span> <span class="keyword">public</span> PoweredDevice &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Printer(<span class="keyword">int</span> printer, <span class="keyword">int</span> power) : PoweredDevice(power) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printer: "</span> &lt;&lt; printer &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span> :</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Copier(<span class="keyword">int</span> scanner, <span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">    : Scanner(scanner, power), Printer(printer, power) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If you were to create a Copier class object, by default you would end up with two copies of the PoweredDevice class ‚Äî one from Printer, and one from Scanner. This has the following structure:</p>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/eu22x.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Copier <span class="title">copier</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* output:</span></span><br><span class="line"><span class="comment">  PoweredDevice: 3</span></span><br><span class="line"><span class="comment">  Scanner: 1</span></span><br><span class="line"><span class="comment">  PoweredDevice: 3</span></span><br><span class="line"><span class="comment">  Printer: 2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As you can see, PoweredDevice <strong>got constructed twice</strong>. To share a base class, simply insert the ‚Äúvirtual‚Äù keyword in the inheritance list of the derived class. This creates what is called a <code>virtual base class</code>, which means there is only one base object that is shared. Here is an example (without constructors for simplicity) showing how to use the virtual keyword to create a shared base class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Powered</span> <span class="title">Device</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span> :</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>Now, when you create a Copier class, you will get only one copy of PoweredDevice that will be shared by both Scanner and Printer.</p>
<p>However, this leads to one more problem: if Scanner and Printer share a PoweredDevice base class, who is responsible for creating it? The answer, as it turns out, is Copier. The Copier constructor is responsible for creating PoweredDevice. Consequently, <strong>this is one time when Copier is allowed to call a non-immediate-parent constructor directly</strong>.</p>
<p><strong>Note that:</strong></p>
<ul>
<li><p>First, virtual base classes are always created before non-virtual base classes, which ensures all bases get created before their derived classes.</p>
</li>
<li><p>Second, note that the Scanner and Printer constructors still have calls to the PoweredDevice constructor. When creating an instance of Copier, these constructor calls are simply ignored because Copier is responsible for creating the PoweredDevice, not Scanner or Printer. However, if we were to create an instance of Scanner or Printer, those constructor calls would be used, and normal inheritance rules apply.</p>
</li>
<li><p>Third, if a class inherits one or more classes that have virtual parents, the most derived class is responsible for constructing the virtual base class. In this case, Copier inherits Printer and Scanner, both of which have a PoweredDevice virtual base class. Copier, the most derived class, is responsible for creation of PoweredDevice. Note that this is true even in a single inheritance case: if Copier was singly inherited from Printer, and Printer was virtually inherited from PoweredDevice, Copier is still responsible for creating PoweredDevice.</p>
</li>
<li><p>Fourth, <strong>all classes inheriting a virtual base class will have a virtual table</strong>, even if they would normally not have one otherwise, and thus be larger by a pointer.</p>
</li>
</ul>
<p>Because Scanner and Printer derive virtually from PoweredDevice, Copier will only be one PoweredDevice subobject. Scanner and Printer both need to know how to find that single PoweredDevice subobject, so they can access its members (because after all, they are derived from it). This is typically done through some virtual table magic (which essentially <strong>stores the offset from each subclass to the PoweredDevice subobject)</strong>.</p>
<h3 id="Object-slicing"><a href="#Object-slicing" class="headerlink" title="Object slicing"></a>Object slicing</h3><p>What happens if instead of setting a Base reference or pointer to a Derived object, we simply assign a Derived object to a Base object?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">Base base = derived; <span class="comment">// what happens here?</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base is a "</span> &lt;&lt; base.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; base.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
<p>Remember that <code>derived</code> has a Base part and a Derived part. When we assign a Derived object to a Base object, only the Base portion of the Derived object is copied. The Derived portion is not. In the example above, <code>base</code> receives a copy of the Base portion of <code>derived</code>, but not the Derived portion. That Derived portion has effectively been ‚Äúsliced off‚Äù. Consequently, the assigning of a Derived class object to a Base class object is called <code>object slicing</code> (or slicing for short).</p>
<p>Because variable <code>base</code> does not have a Derived part, <code>base.getName()</code> resolves to <code>Base::getName()</code>.</p>
<p>Used conscientiously, slicing can be benign. However, used improperly, slicing can cause unexpected results in quite a few different ways.</p>
<p>Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Derived</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(<span class="keyword">const</span> Base base)</span> </span>&#123; <span class="comment">// note: base passed by value, not reference</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; base.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">  printName(d); <span class="comment">// oops, didn't realize this was pass by value on the calling end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When you wrote this program, you may not have noticed that base is a value parameter, not a reference. Therefore, when called as printName(d), we might have expected base.getName() to call virtualized function getName() and print ‚ÄúI am a Derived‚Äù, that is not what happens. Instead, Derived object <code>d</code> is sliced and only the Base portion is copied into the base parameter. When base.getName() executes, even though the getName() function is virtualized, there‚Äôs no Derived portion of the class for it to resolve to.</p>
<p><strong>Slicing vectors (std::reference_wrapper&lt;&gt;)</strong></p>
<p>Yet another area where new programmers run into trouble with slicing is trying to implement polymorphism with <code>std::vector</code>. Consider the following program:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Base&gt; v;</span><br><span class="line">v.push_back(Base(<span class="number">5</span>));</span><br><span class="line">v.push_back(Derived(<span class="number">6</span>)); <span class="comment">// Derived is sliced</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; v.size(); ++count) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; v[count].getName() </span><br><span class="line">            &lt;&lt; <span class="string">"with value "</span> &lt;&lt; v[count].getValue() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">I am a Base with value 5</span></span><br><span class="line"><span class="comment">I am a Base with value 6</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Fixing this is a little more difficult. Many new programmers try creating a std::vector of references to an object. Unfortunately, this won‚Äôt compile. <strong>The elements of std::vector must be re-assignable, whereas references can‚Äôt be reassigned (only initialized).</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Base*&gt; v;</span><br><span class="line">v.push_back(<span class="keyword">new</span> Base(<span class="number">5</span>)); <span class="comment">// add a Base object to our vector</span></span><br><span class="line">v.push_back(<span class="keyword">new</span> Derived(<span class="number">6</span>)); <span class="comment">// add a Derived object to our vector</span></span><br><span class="line"><span class="comment">// but later you need to delete the pointers by forloop</span></span><br></pre></td></tr></table></figure>
<p>But it‚Äôs quite a bit of additional headache since you now have to deal with dynamic memory allocation.</p>
<p>There‚Äôs one other way to resolve this. The standard library provides a useful workaround: the <code>std::reference_wrapper</code> class. Essentially, std::reference_wrapper is a class that acts like a reference, but also <strong>allows assignment and copying</strong>, so it‚Äôs compatible with std::vector.</p>
<p>The good news is that you don‚Äôt really need to understand how it works to use it. All you need to know are three things:</p>
<ol>
<li>std::reference_wrapper lives in the <code>&lt;functional&gt;</code> header</li>
<li>When you create your std::reference_wrapper wrapped object, the object <code>can&#39;t be an anonymous object</code> (since anonymous objects have expression scope would leave the reference dangling)</li>
<li>When you want to get your object back out of std::reference_wrapper, you use the <code>get()</code> member function.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::reference_wrapper&lt;Base&gt; &gt; v;</span><br><span class="line"><span class="comment">// our vector is a vector of std::reference wrapper wrapped Base (not Base&amp;)</span></span><br><span class="line"><span class="function">Base <span class="title">b</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">v.push_back(b);</span><br><span class="line">v.push_back(d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; v.size(); ++count) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v[count].get().getName() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="comment">// avoids having to deal with dynamic memory</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>The Frankenobject</strong></p>
<p>In the above examples, we‚Äôve seen cases where slicing lead to the wrong result because the derived class had been sliced off. Now let‚Äôs take a look at another dangerous case where the derived object still exists!</p>
<p>Consider the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Derived <span class="title">d1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Derived <span class="title">d2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">Base &amp;b = d2;</span><br><span class="line">b = d1;  <span class="comment">// this line is problematic</span></span><br></pre></td></tr></table></figure>
<p>The first three lines in the function are pretty straightforward. Create two Derived objects, and set a Base reference to the second one.</p>
<p>The fourth line is where things go astray. Since b points at d2, and we‚Äôre assigning d1 to b, you might think that the result would be that d1 would get copied into d2 ‚Äî and it would, if b were a Derived. But b is a Base, and the operator= that C++ provides for classes isn‚Äôt virtual by default. Consequently, only the Base portion of d1 is copied into d2.</p>
<p>As a result, you‚Äôll discover that d2 now has the Base portion of d1 and the Derived portion of d2. In this particular example, that‚Äôs not a problem (because the Derived class has no data of its own), but in most cases, you‚Äôll have just created a <code>Frankenobject</code> ‚Äî composed of parts of multiple objects. Worse, there‚Äôs no easy way to prevent this from happening (other than avoiding assignments like this as much as possible).</p>
<p><strong>Note:</strong> (In non-inheritance case, types are not matched)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test1 t1;</span><br><span class="line">  Test2 t2;</span><br><span class="line">  Test1 &amp;a = t1;</span><br><span class="line">  a = t2;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    no viable overloaded operator=</span></span><br><span class="line"><span class="comment">    no operator "=" matches these operands -- operand types are: Test1 = Test2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Although C++ supports assigning derived objects to base objects via object slicing, in general, this is likely to cause nothing but headaches, and <strong>you should generally try to avoid slicing</strong>. Make sure your function parameters are references (or pointers) and try to <strong>avoid any kind of <code>pass-by-value</code> when it comes to derived classes</strong>.</p>
<p><strong>Note:</strong> when <code>reassigning</code> references or objects, consider potential object-slicing problems.</p>
<h3 id="Dynamic-casting-downcasting"><a href="#Dynamic-casting-downcasting" class="headerlink" title="Dynamic casting (downcasting)"></a>Dynamic casting (downcasting)</h3><p><strong>The need for dynamic_cast</strong></p>
<p>When dealing with polymorphism, you‚Äôll often encounter cases where you have a pointer to a base class, but you want to access some information that exists only in a derived class.</p>
<p>In a program, function getObject() always returns a <code>Base pointer</code>, but that pointer may be pointing to either a Base or a Derived object. In the case where the pointer is pointing to a Derived object, how would we call Derived::getName()?</p>
<p>(Base doesn‚Äôt have getName(), m_name members)</p>
<p>One way would be to add a virtual function to Base called getName() (so we could call it with a Base object, and have it dynamically resolve to Derived::getName()). But what would this function return if you called it with a Base object? There isn‚Äôt really any value that makes sense. Furthermore, we would be polluting our Base class with things that really should only be the concern of the Derived class.</p>
<p>C++ provides a casting operator named <code>dynamic_cast</code> that can be used for <code>downcasting</code>. Although dynamic casts have a few different capabilities, by far the most common use for dynamic casting is for converting base-class pointers into derived-class pointers. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base *b = getObject(<span class="literal">true</span>);  <span class="comment">// true means return a pointer to Base object</span></span><br><span class="line">Derived *d = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(b);</span><br><span class="line"><span class="comment">// use dynamic cast to donvert Base pointer into Derived pointer</span></span><br><span class="line"><span class="keyword">delete</span> b;</span><br></pre></td></tr></table></figure>
<p><strong>dynamic_cast failure</strong></p>
<p>But the above situation makes an assumption that b is pointing to a Derived object! When we try to dynamic_cast that to a Derived, it will fail, because the conversion can‚Äôt be made.</p>
<p>If a dynamic_cast fails, the result of the conversion will be a <code>null pointer</code>.</p>
<p>Because we haven‚Äôt checked for a null pointer result, we access d-&gt;getName(), which will try to dereference a null pointer, leading to <code>undefined behavior (probably a crash)</code>.</p>
<p><strong>Rule:</strong> Always ensure your dynamic casts actually succeeded by checking for a null pointer result.</p>
<p>Note that because dynamic_cast does some consistency checking at runtime (to ensure the conversion can be made), <strong>use of dynamic_cast does incur a performance penalty</strong>.</p>
<p>Also note that there are several cases where downcasting using dynamic_cast will not work:</p>
<ol>
<li>With <code>protected</code> or <code>private</code> inheritance.</li>
<li>For classes that do not declare or inherit any virtual functions (and thus don‚Äôt have a virtual table). <ul>
<li>although we set functions virtual in the base class, there is no virtual table (but a null VP pointer) if we don‚Äôt override the virtual functions (note: we don‚Äôt need to specify the virutal keyword in the subclass)</li>
</ul>
</li>
<li>In certain cases involving virtual base classes (see <a href="https://msdn.microsoft.com/en-us/library/cby9kycs.aspx" target="_blank" rel="noopener">this page</a> for an example of some of these cases, and how to resolve them).</li>
</ol>
<p><strong>Downcasting with static_cast</strong></p>
<p>It turns out that downcasting can also be done with <code>static_cast</code>. <strong>The main difference is that static_cast does no runtime type checking to ensure that what you‚Äôre doing makes sense.</strong> This makes using static_cast faster, but more dangerous. If you cast a <code>Base*</code> to a <code>Derived*</code>, it will ‚Äúsucceed‚Äù even if the Base pointer isn‚Äôt pointing to a Derived object. This will result in undefined behavior when you try to access the resulting Derived pointer (that is actually pointing to a Base object).</p>
<p>If you‚Äôre absolutely sure that the pointer you‚Äôre downcasting will succeed, then using static_cast is acceptable. One way to ensure that you know what type of object you‚Äôre pointing to is to use a virtual function to indicate a type of a class. Here‚Äôs one (not great because it uses a global variable) way to do that:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ClassID &#123;</span><br><span class="line">  BASE,</span><br><span class="line">  DERIVED</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> ClassID <span class="title">getClassID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> BASE; &#125;</span><br><span class="line"><span class="comment">// Derived</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> ClassID <span class="title">getClassID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> DERIVED; &#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Base *b = getObject(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (b-&gt;getClassID() == DERIVED) &#123;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dynamic_cast and references</strong></p>
<p>Although all of the above examples show dynamic casting of pointers (which is more common), dynamic_cast can also be used with references. This works analogously to how dynamic_cast works with pointers.</p>
<p>Because C++ does not have a ‚Äúnull reference‚Äù, dynamic_cast can‚Äôt return a null reference upon failure. Instead, if the dynamic_cast of a reference fails, an exception of type <code>std::bad_cast</code> is thrown.</p>
<p><strong>dynamic_cast vs static_cast</strong></p>
<p>New programmers are sometimes confused about when to use static_cast vs dynamic_cast. The answer is quite simple: <strong>use static_cast unless you‚Äôre downcasting</strong>, in which case dynamic_cast is usually a better choice. However, you should also consider avoiding casting altogether and just using virtual functions.</p>
<p><strong>Downcasting vs virtual functions</strong></p>
<p>There are some developers who believe dynamic_cast is evil and indicative of a bad class design. Instead, these programmers say you should use virtual functions.</p>
<p>In general, using a virtual function should be preferred over downcasting. However, there are times when downcasting is the better choice:</p>
<ul>
<li>When you <strong>cannot modify the base class</strong> to add a virtual function<br>(e.g. because the base class is part of the standard library)</li>
<li>When you need access to something that is derived-class specific<br>(e.g. an access function that only exists in the derived class <strong>which means not using polymorphism</strong>)</li>
<li>When adding a virtual function to your base class doesn‚Äôt make sense<br>(e.g. there is no appropriate value for the base class to return). Using a pure virtual function may be an option here if you don‚Äôt need to instantiate the base class.</li>
</ul>
<h3 id="Printing-inherited-classes-using-operator-lt-lt"><a href="#Printing-inherited-classes-using-operator-lt-lt" class="headerlink" title="Printing inherited classes using operator&lt;&lt;"></a>Printing inherited classes using operator&lt;&lt;</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Base() &#123;&#125; </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Derived d;</span><br><span class="line">	Base &amp;b = d;</span><br><span class="line">	b.print(); <span class="comment">// will call Derived::print()</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// If we want to mix it with cout, it's kind of messy</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b is a "</span>;</span><br><span class="line">	b.print(); <span class="comment">// put in middle</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Our purpose is like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b is a "</span> &lt;&lt; b &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// much better</span></span><br></pre></td></tr></table></figure>
<p>Let‚Äôs start by overloading operator&lt;&lt; in the typical way:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Base() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>; &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> Base &amp;b) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">"Base"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Derived() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> Derived &amp;d) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">"Derived"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  Derived d;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="comment">// okay</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// but consider</span></span><br><span class="line">  Base &amp;bref = d;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bref &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="comment">/* output: Base (not what we want) */</span>  </span><br><span class="line">  <span class="comment">/* this is because our version of operator&lt;&lt; isn't virtual */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Can we make operator&lt;&lt; virtual?</strong> No!</p>
<ul>
<li>First, <strong>only member functions can be virtualized.</strong></li>
<li>Second, even if we could virtualize operator&lt;&lt; there‚Äôs the problem that <strong>the function parameters for Base::operator&lt;&lt; and Derived::operator&lt;&lt; differ</strong>. Consequently, the Derived version wouldn‚Äôt be considered an override of the Base version, and thus be ineligible for virtual function resolution.</li>
</ul>
<p><strong>The solution</strong></p>
<p>First, we set up operator&lt;&lt; as a friend in our base class as usual. But instead of having operator&lt;&lt; do the printing itself, we delegate that responsibility to a normal member function that can be virtualized!</p>
<p>Here‚Äôs the full solution that works:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Base() &#123;&#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> Base &amp;b) &#123;</span><br><span class="line">      <span class="comment">// Delegate printing responsibility for printing to member function print()</span></span><br><span class="line">      <span class="keyword">return</span> b.print(out);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We'll rely on member function print() to do the actual printing</span></span><br><span class="line">  <span class="comment">// Because print is a normal member function, it can be virtualized</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">"Base"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Derived() &#123;&#125;</span><br><span class="line">  <span class="comment">// Note that we don't need to define an operator&lt;&lt; for each derived class! </span></span><br><span class="line">  <span class="comment">// The version that handles Base objects works just fine for both Base objects and any class derived from Base!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">"Derived"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  Derived d;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">  Base &amp;bref = d;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bref &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h2><h3 id="Function-templates"><a href="#Function-templates" class="headerlink" title="Function templates"></a>Function templates</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Having to specify different ‚Äúflavors‚Äù of the same function where the only thing that changes is the type of the parameters can become a maintenance headache and time-waster, and it also violates the general programming guideline that duplicate code should be minimized as much as possible. Wouldn‚Äôt it be nice if we could write one version of max() that was able to work with parameters of ANY type?</p>
<p>In C++, function templates are functions that serve as a <code>pattern</code> for creating other similar functions. The basic idea behind function templates is to create a function without having to specify the exact type(s) of some or all of the variables. Instead, we define the function using placeholder types, called <code>template type parameters</code>. Once we have created a function using these placeholder types, we have effectively created a ‚Äúfunction stencil‚Äù.</p>
<p>When you call a template function, the <code>compiler</code> ‚Äústencils‚Äù out a copy of the template, replacing the placeholder types with the actual variable types from the parameters in your function call! Using this methodology, the compiler can create multiple ‚Äúflavors‚Äù of a function from one template! We‚Äôll take a look at this process in more detail in the next lesson.</p>
<p>You can name your placeholder types almost anything you want, so long as it‚Äôs not a reserved word. However, in C++, it‚Äôs customary to name your template types the letter T (short for ‚ÄúType‚Äù).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, T y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In order to make this work, we need to tell the compiler two things: <strong>First</strong>, that this is a template definition. <strong>Second</strong>, that T is a placeholder type. We can do both of those things in one line, using what is called a template parameter declaration:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// this is the template parameter declaration</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, T y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To create a template type parameter, use either the keyword <code>typename</code> or <code>class</code>. There is no difference between the two keywords in this context, so which you use is up to you. Note that if you use the class keyword, the type passed in does not actually have to be a class (it can be a fundamental variable, pointer, or anything else that matches). Then you name your type (usually ‚ÄúT‚Äù, ‚ÄúT1‚Äù, ‚ÄúT2‚Äù, ‚ÄúS‚Äù).</p>
<p><strong>One final note:</strong> Because the function argument passed in for type T could be a class type, and it‚Äôs generally not a good idea to pass classes by value, it would be better to make the parameters and return types of our templated function const references:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function-template-instances"><a href="#Function-template-instances" class="headerlink" title="Function template instances"></a>Function template instances</h3><p>C++ does not compile the template function directly. Instead, at compile time, when the compiler encounters a call to a template function, it <strong>replicates</strong> the template function and <strong>replaces</strong> the template type parameters with actual types. The function with actual types is called a <code>function template instance</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> &amp;T x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When compiling your program, the compiler encounters a call to the template function:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = max(<span class="number">3</span>, <span class="number">7</span>);  <span class="comment">// calls max(int, int)</span></span><br></pre></td></tr></table></figure>
<p>The compiler says, ‚Äúoh, we want to call max(int, int)‚Äù. The compiler replicates the function template and creates the template instance max(int, int):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The compiler is smart enough to know it only needs to create one template instance per set of unique type parameters (per file). It‚Äôs also worth noting that <strong>if you create a template function but do not call it, no template instances will be created</strong>.</p>
<p>Using template with classes:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_cents;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Cents(<span class="keyword">int</span> cents) : m_cents(cents) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Cents <span class="title">nickle</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">  <span class="function">Cents <span class="title">dime</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  Cents bigger = max(nikcle, dime);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The complier will try to compile this function. See the problem here? C++ has no idea how to evaluate x &gt; y! Consequently, this will produce a fairly-tame looking compile error, like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C2676: binary &apos;&gt;&apos;: &apos;const Cents&apos; does not define this operator or a conversion to a type acceptable to the predefined operator</span><br></pre></td></tr></table></figure>
<p>To get around this problem, simply overload the operator &gt; for any class we wish to use max() with:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Cents &amp;c1, <span class="keyword">const</span> Cents &amp;c2) &#123;</span><br><span class="line">  <span class="keyword">return</span> (c1.m_cents &gt; c2.m_cents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Another example:</strong></p>
<p>Calculate the average of a number of objects in an array:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">average</span>(<span class="title">T</span> *<span class="title">array</span>, <span class="title">int</span> <span class="title">length</span>) &#123;</span></span><br><span class="line">  T sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; length; ++count) &#123;</span><br><span class="line">    sum += <span class="built_in">array</span>[count];</span><br><span class="line">  &#125;</span><br><span class="line">  sum /= length;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> array1[] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; average(array1, <span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">double</span> array2[] = &#123; <span class="number">3.12</span>, <span class="number">3.45</span>, <span class="number">9.23</span>, <span class="number">6.34</span> &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; average(array2, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now let‚Äôs see what happens when we call this function on our Cents class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// same as above</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">average</span>(<span class="title">T</span> *<span class="title">array</span>, <span class="title">int</span> <span class="title">length</span>) &#123;</span></span><br><span class="line">  T sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">    sum += <span class="built_in">array</span>[count];</span><br><span class="line">  sum /= length;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_cents;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Cents(<span class="keyword">int</span> cents) : m_cents(cents) &#123;&#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Cents &amp;c1, <span class="keyword">const</span> Cents &amp;c2) &#123;</span><br><span class="line">    <span class="keyword">return</span> (c1.m_cents &gt; c2.m_cents);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Cents array3[] = &#123; Cents(<span class="number">5</span>), Cents(<span class="number">10</span>), Cents(<span class="number">15</span>), Cents(<span class="number">14</span>) &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; average(array3, <span class="number">4</span>) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The compiler goes berserk and produces a ton of error messages!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\consoleapplication1\main.cpp(55): error C2679: binary &apos;&lt;&lt;&apos;: no operator found which takes a right-hand operand of type &apos;Cents&apos; (or there is no acceptable conversion)</span><br></pre></td></tr></table></figure>
<p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/usjnr.jpg" alt=""></p>
<p>Remember what I said about crazy error messages? We hit the motherload! Despite looking intimidating, these are actually quite straightforward. <strong>The first line is telling you that it couldn‚Äôt find an overloaded operator&lt;&lt; for the Cents class.</strong> All of the lines in the middle are all of the different functions it tried to match with but failed. The last error points out the function call that spawned this wall of errors.</p>
<p>Remember that average() returns a Cents object, and we are trying to stream that object to std::cout using the &lt;&lt; operator. However, we haven‚Äôt defined the &lt;&lt; operator for our Cents class yet. Let‚Äôs do that:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_cents;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Cents(<span class="keyword">int</span> cents) : m_cents(cents) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Cents &amp;c1, <span class="keyword">const</span> Cents &amp;c2) &#123;</span><br><span class="line">    <span class="keyword">return</span> (c1.m_cents &gt; c2.cents);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> Cents &amp;cents) &#123;</span><br><span class="line">    out &lt;&lt; cents.m_cents &lt;&lt; <span class="string">" cents"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Then it shows another error:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:test.cpp(14) : error C2676: binary &apos;+=&apos; : &apos;Cents&apos; does not define this operator or a conversion to a type acceptable to the predefined operator</span><br></pre></td></tr></table></figure>
<p>The reason we are getting an error message is because of the following line: <code>sum += array[count];</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overloaded member function</span></span><br><span class="line">Cents&amp; <span class="keyword">operator</span>+=(Cents cents) &#123;</span><br><span class="line">  m_cents += cents.m_cents;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cents&amp; <span class="keyword">operator</span>/=(<span class="keyword">int</span> value) &#123;</span><br><span class="line">  m_cents /= (<span class="keyword">double</span>) value;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Remember in the above examples, <strong>we barely modify our templates to achieve our goals.</strong></p>
<h3 id="Template-classes"><a href="#Template-classes" class="headerlink" title="Template classes"></a>Template classes</h3><p><strong>Templates and container classes</strong></p>
<p>Combine <code>IntArray</code> and <code>DoubleArray</code> classes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">This</span> <span class="title">is</span> <span class="title">a</span> <span class="title">template</span> <span class="title">class</span>, <span class="title">the</span> <span class="title">user</span> <span class="title">will</span> <span class="title">provide</span> <span class="title">the</span> <span class="title">data</span> <span class="title">type</span> <span class="title">for</span> <span class="title">T</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_length;</span><br><span class="line">  T *m_data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Array() &#123;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">    m_data = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Array(<span class="keyword">int</span> length) &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[length];</span><br><span class="line">    m_length = length;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Array() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  T&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> index) &#123;</span><br><span class="line">    assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>; <span class="comment">// templated getLength() function on defined below</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// member functions defined outside the class need their own template declaration</span></span><br><span class="line"><span class="keyword">int</span> Array&lt;T&gt;::getLength() &#123; <span class="keyword">return</span> m_length; &#125; <span class="comment">// note that the class name is Array&lt;T&gt;, not Array</span></span><br></pre></td></tr></table></figure>
<p>Note that we‚Äôve also defined the <code>getLength()</code> function outside of the class declaration. This isn‚Äôt necessary, but new programmers typically stumble when trying to do this for the first time due to the syntax, so an example is instructive. <strong>Each templated member function declared outside the class declaration needs its own template declaration</strong>. Also, note that the name of the templated array class is Array<t>, not Array ‚Äî <strong>Array would refer to a non-templated version of a class named Array.</strong></t></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// short example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Array&lt;<span class="keyword">int</span>&gt; intArray(<span class="number">12</span>);</span><br><span class="line">  Array&lt;<span class="keyword">double</span>&gt; doubleArray(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; intArray.getLength(); ++count) &#123;</span><br><span class="line">    intArray[count] = count;</span><br><span class="line">    doubleArray[count] = count + <span class="number">0.5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> count = intArray.getLength() - <span class="number">1</span>; count &gt;= <span class="number">0</span>; --count) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intArray[count] &lt;&lt; <span class="string">"\t"</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Template classes are instanced in the same way template functions are ‚Äî the compiler stencils out a copy upon demand, with the template parameter replaced by the actual data type the user needs, and then compiles the copy. If you don‚Äôt ever use a template class, the compiler won‚Äôt even compile it.</p>
<p>Template classes are ideal for implementing <code>container classes</code>, because it is highly desirable to have containers work across a wide variety of data types, and templates allow you to do so without duplicating code. Although the syntax is ugly, and the error messages can be cryptic, template classes are truly one of C++‚Äôs best and most useful features.</p>
<p><strong>Splitting up template classes</strong></p>
<p><strong>A template is not a class or a function ‚Äî it is a stencil used to create classes or functions.</strong> As such, it does not work in quite the same way as normal functions or classes. In most cases, this isn‚Äôt much of an issue. However, there is one area that commonly causes problems for developers.</p>
<p>With non-template classes, the common procedure is to put the class definition in a header file, and the member function definitions in a similarly named code file. In this way, the source for the class is compiled as a separate project file. However, with templates, this does not work. Consider this example:</p>
<p>Array.h:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> index) &#123;</span><br><span class="line">    assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Array.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Array&lt;T&gt;::getLength() &#123; <span class="keyword">return</span> m_length; &#125;</span><br></pre></td></tr></table></figure>
<p>main.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array&lt;<span class="keyword">int</span>&gt; intArray(<span class="number">12</span>);</span><br><span class="line">Array&lt;<span class="keyword">double</span>&gt; indoubleArray(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>The above program will compile, but cause a linker error:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unresolved external symbol &quot;public: int __thiscall Array::getLength(void)&quot; (?GetLength@?$Array@H@@QAEHXZ)</span><br></pre></td></tr></table></figure>
<p><strong>In order for the compiler to use a template, it must see both the template definition (not just a declaration) and the template type used to instantiate the template.</strong></p>
<p>Also remember that <strong>C++ compiles files individually</strong>. When the <code>Array.h</code> header is #included in <code>main.cpp</code>, the template class definition is copied into <code>main.cpp</code>. When the compiler sees that we need two template instances, <code>Array&lt;int&gt;</code>, and <code>Array&lt;double&gt;</code>, it will instantiate these, and compile them as part of <code>main.cpp</code>. <strong>However</strong>, when it gets around to compiling <code>Array.cpp</code> separately, it will have forgotten that we need an <code>Array&lt;int&gt;</code> and <code>Array&lt;double&gt;</code>, so that template function is never instantiated. Thus, we get a linker error, because the compiler can‚Äôt find a definition for <code>Array&lt;int&gt;::getLength()</code> or <code>Array&lt;double&gt;::getLength()</code>.</p>
<p><strong>The easiest way is to simply put all of your template class code in the header file</strong> (in this case, put the contents of <code>Array.cpp</code> into <code>Array.h</code>, below the class). In this way, when you #include the header, all of the template code will be in one place. The <strong>upside</strong> of this solution is that it is simple. The <strong>downside</strong> here is that if the template class is used in many places, you will end up with many local copies of the template class, which can increase your compile and link times (your linker should remove the duplicate definitions, so it shouldn‚Äôt bloat your executable). <strong>This is our preferred solution unless the compile or link times start to become a problem.</strong></p>
<p>If you feel that putting the <code>Array.cpp</code> code into the <code>Array.h</code> header makes the header too long/messy, an alternative is to rename <code>Array.cpp</code> to <code>Array.inl</code> (.inl stands for inline), and then include Array.inl from the bottom of the Array.h header. That yields the same result as putting all the code in the header, but helps keep things a little cleaner.</p>
<p>Other solutions involve <code>#including</code> .cpp files in .h files, but we don‚Äôt recommend these because of the non-standard usage of #include.</p>
<p>Another alternative is to use a three-file approach. The template class definition goes in the header. The template class member functions goes in the code file. Then you add a third file, which contains all of the instantiated classes you need:</p>
<p>templates.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ensure the full Array template definition can be seen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.cpp"</span> <span class="comment">// we're breaking best practices here, but only in this one place</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// #include other .h and .cpp template definitions you need here</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;int&gt;;</span> <span class="comment">// Explicitly instantiate template Array&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;double&gt;;</span> <span class="comment">// Explicitly instantiate template Array&lt;double&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// instantiate other templates here</span></span><br></pre></td></tr></table></figure>
<p>The <code>template class</code> command causes the compiler to explicitly instantiate the template class. In the above case, the compiler will stencil out both <code>Array&lt;int&gt;</code> and <code>Array&lt;double&gt;</code> inside of <code>templates.cpp</code>. Because <code>templates.cpp</code> is inside our project, this will then be compiled. These functions can then be linked to from elsewhere.</p>
<h3 id="Non-type-parameters"><a href="#Non-type-parameters" class="headerlink" title="Non-type parameters"></a>Non-type parameters</h3><p>In previous lessons, you‚Äôve learned how to use template type parameters to create functions and classes that are type independent. However, <code>template type parameters</code> are not the only type of template parameters available. Template classes and functions can make use of another kind of template parameter known as a <code>non-type parameter</code>.</p>
<p><strong>Non-type parameters</strong></p>
<p>A template non-type parameter is a special type of parameter that does not substitute for a type, but is instead replaced by a value. A non-type parameter can be any of the following:</p>
<ul>
<li>A value that has an <code>integer</code> type or <code>enumeration</code></li>
<li>A pointer or reference to a class object</li>
<li>A pointer or reference to a function</li>
<li>A pointer or reference to a class member function</li>
<li>std::nullptr_t</li>
</ul>
<p>In the following example, we create a StaticArray class that uses both a type parameter and a non-type parameter. The type parameter controls <code>the data type</code> of the array, and the non-type parameter controls <code>how large the static array is</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">size</span> <span class="title">is</span> <span class="title">the</span> <span class="title">non</span>-<span class="title">type</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T m_array[size];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">T* <span class="title">getArray</span><span class="params">()</span></span>;</span><br><span class="line">  T&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> m_array[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Showing how a function for a class with a non-type parameter is defined outside of the class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">StaticArray</span>&lt;T, size&gt;:</span>:getArray() &#123;</span><br><span class="line">  <span class="keyword">return</span> m_array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  StaticArray&lt;<span class="keyword">double</span>, <span class="number">4</span>&gt; doubleArray;</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One noteworthy thing about the above example is that <strong>we do not have to dynamically allocate the <code>m_array</code> member variable</strong>! This is because for any given instance of the <code>StaticArray</code> class, size is actually <code>constant</code>. For example, if you instantiate a <code>StaticArray&lt;int, 12&gt;</code>, the compiler replaces <code>size</code> with 12. Thus <code>m_array</code> is of type <code>int[12]</code>, which can be allocated statically. (happens in compile time)</p>
<p>This functionality is used by the standard library class std::array. When you allocate a std::array<int, 5="">, the int is a type parameter, and the 5 is a non-type parameter!</int,></p>
<h3 id="Function-template-specialization"><a href="#Function-template-specialization" class="headerlink" title="Function template specialization"></a>Function template specialization</h3><p>When instantiating a function template for a given type, the compiler stencils out a copy of the templated function and replaces the template type parameters with the actual types used in the variable declaration. <strong>This means a particular function will have the same implementation details for each instanced type (just using different types).</strong> While most of the time, this is exactly what you want, occasionally there are cases where it is useful to implement a templated function slightly different for a specific data type.</p>
<p><code>Template specialization</code> is one way to accomplish this.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Storage(T value) &#123;</span><br><span class="line">    m_value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Storage() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Define some storage units</span></span><br><span class="line">  Storage&lt;<span class="keyword">int</span>&gt; nValue(<span class="number">5</span>);</span><br><span class="line">  Storage&lt;<span class="keyword">double</span>&gt; dValue(<span class="number">6.7</span>);</span><br><span class="line">  <span class="comment">// Print out some values</span></span><br><span class="line">  nValue.print();  <span class="comment">// 5</span></span><br><span class="line">  dValue.print();  <span class="comment">// 6.7</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, let‚Äôs say we want double values (and only double values) to output in scientific notation. To do so, we can use a <code>function template specialization</code> (sometimes called a full or explicit function template specialization) to create a specialized version of the print() function for type double. This is extremely simple: simply define the specialized function (if the function is a member function, do so outside of the class definition), replacing the template type with the specific type you wish to redefine the function for. Here is our specialized print() function for doubles:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Storage&lt;<span class="keyword">double</span>&gt;::print() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific &lt;&lt; m_value &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="comment">// 6.700000e+000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When the compiler goes to instantiate <code>Storage&lt;double&gt;::print()</code>, it will see we‚Äôve already explicitly defined that function, and it will use the one we‚Äôve defined instead of stenciling out a version from the generic templated class.</p>
<p>The <code>template &lt;&gt;</code> tells the compiler that this is a template function, but that there are <code>no template parameters</code> (since in this case, we‚Äôre explicitly specifying all of the types). Some compilers may allow you to omit this, but it‚Äôs proper to include it.</p>
<p><strong>Another example:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// continue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Dynamically allocate a temporary string</span></span><br><span class="line">  <span class="keyword">char</span> *str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ask user for their name</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your name: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Store the name</span></span><br><span class="line">  Storage&lt;<span class="keyword">char</span>*&gt; storage(str);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] str;</span><br><span class="line"></span><br><span class="line">  str.print(); <span class="comment">// print</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As it turns out, instead of printing the name the user input, <code>storage.print()</code> prints garbage! What‚Äôs going on here?</p>
<p>When Storage is instantiated for type <code>char*</code>, the constructor for <code>Storage&lt;char*&gt;</code> looks like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span> *&gt;::Storage(<span class="keyword">char</span> *value) &#123;</span><br><span class="line">  m_value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fixed</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span> *&gt;::Storage(<span class="keyword">char</span> *valueP) &#123;</span><br><span class="line">  <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (valueP[length] != <span class="string">'\0'</span>)</span><br><span class="line">    ++length;</span><br><span class="line">  ++length;  <span class="comment">// +1 to account for null terminator;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate memory to hold the valueP string</span></span><br><span class="line">  m_value = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; length; ++count) &#123;</span><br><span class="line">    m_value[count] = valueP[count];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// we need to add destructor to avoid memory leak</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span> *&gt;::~Storage() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] m_value;   <span class="comment">// use delete[] to correspond new[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Class-template-specialization"><a href="#Class-template-specialization" class="headerlink" title="Class template specialization"></a>Class template specialization</h3><p>It is not only possible to specialize functions, it is also possible to specialize an entire class!</p>
<p>Consider the case where you want to design a class that stores 8 objects. Here‚Äôs a simplified class to do so:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage8</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T m_array[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">const</span> T &amp;value)</span> </span>&#123;</span><br><span class="line">    m_array[index] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> T&amp; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_array[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Consider when we use it to store bool:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Storage8&lt;<span class="keyword">bool</span>&gt; boolStorage;</span><br></pre></td></tr></table></figure>
<p>A variable of type bool ends up using an entire byte even though technically it only needs a single bit to store its true or false value! Thus, a bool is 1 bit of useful information and 7 bits of wasted space. Our <code>Storage8&lt;bool&gt; class</code>, which contains 8 bools, is 1 byte worth of useful information and 7 bytes of wasted space.</p>
<p>As it turns out, using some basic bit logic, it‚Äôs possible to compress all 8 bools into a single byte, eliminating the wasted space altogether. However, in order to do this, we‚Äôll need to revamp the class when used with type bool, replacing the array of 8 bools with a variable that is a single byte in size. While we could create an entirely new class to do so, this has one major downside: we have to give it a different name. <strong>Then the programmer has to remember that <code>Storage8&lt;T&gt;</code> is meant for non-bool types, whereas Storage8Bool (or whatever we name the new class) is meant for bools. That‚Äôs needless complexity we‚Äôd rather avoid. Fortunately, C++ provides us a better method: class template specialization.</strong></p>
<p><strong>Class template specialization</strong></p>
<p><code>Class template specializations</code> are treated as <code>completely independent</code> classes, even though they are allocated in the same way as the <code>templated class</code>. This means that we can change anything and everything about our specialization class, including the way it‚Äôs implemented and even the functions it makes public, just as if it were an <code>independent class</code>. Here‚Äôs our specialized class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage8</span>&lt;bool&gt; &#123;</span> <span class="comment">// we're specializing Storage8 for bool</span></span><br><span class="line"><span class="comment">// What follows is just standard class implementation</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> m_data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Storage8() : m_data(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">bool</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mask = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">    <span class="keyword">if</span> (value)</span><br><span class="line">      m_data |= mask;</span><br><span class="line">      <span class="comment">// use bitwise-or to turn that bit on</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      m_data &amp;= ~mask;</span><br><span class="line">      <span class="comment">// use bitwise-and the inverse mask to turn that bit off</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mask = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">    <span class="keyword">return</span> (m_data &amp; mask);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Note that we start off with <code>template&lt;&gt;</code>. The template keyword tells the compiler that what follows is templated, and the empty angle braces means that there aren‚Äôt any template parameters. <strong>In this case, there aren‚Äôt any template parameters because we‚Äôre replacing the only template parameter (typename T) with a specific type (bool).</strong></p>
<p>Now: </p>
<ul>
<li>When we declare a class of type <code>Storage8&lt;T&gt;</code>, where T is not a bool, we‚Äôll get a version stenciled from the generic templated <code>Storage8&lt;T&gt;</code> class.</li>
<li>When we declare a class of type <code>Storage8&lt;bool&gt;</code>, we‚Äôll get the specialized version we just created.</li>
</ul>
<p><strong>Note:</strong> we have kept the publicly exposed interface of both classes the same ‚Äî while C++ gives us free reign to add, remove, or change functions of <code>Storage8&lt;bool&gt;</code> as we see fit, keeping a consistent interface means the programmer can use either class in exactly the same manner.</p>
<h3 id="Partial-template-specialization"><a href="#Partial-template-specialization" class="headerlink" title="Partial template specialization"></a>Partial template specialization</h3><p>Let‚Äôs take another look at the Static Array class we used in one of our previous examples:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">type</span> <span class="title">parameter</span> &amp; <span class="title">expression</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T m_array[size]</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">T* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line">  T&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> m_array[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Now, let‚Äôs say we wanted to write a function to print out the whole array. Although we could implement this as a member function, we‚Äôre going to do it as a <code>non-member function</code> instead because it will make the successive examples easier to follow.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> size&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;T, size&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; size; ++count) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[count] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// so in main we can do:</span></span><br><span class="line">StaticArray&lt;<span class="keyword">int</span>, <span class="number">4</span>&gt; int4;</span><br><span class="line">print(int4);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  output: 0 1 2 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Although this works, it has a <code>design flaw</code>. Consider the following:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StaticArray&lt;<span class="keyword">char</span>, <span class="number">14</span>&gt; char14;</span><br><span class="line">strcpy_s(char14.getArray(), <span class="number">14</span>, <span class="string">"Hello World!"</span>);</span><br><span class="line">print(char14);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  output: H e l l o ,  w o r l d ! </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>For non-char types, it makes sense to put a space between each array element, so they don‚Äôt run together. However, with a char type, it makes more sense to print everything run together as a C-style string, which our print() function doesn‚Äôt do.</p>
<p>One might first think of using <code>template specialization</code>. The problem with <code>full template specialization</code> is that all template parameters must be explicitly defined.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> size&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;T, size&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// for-loop</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Override print() for fully specialized StaticArray&lt;char, 14&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;<span class="keyword">char</span>, <span class="number">14</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// for-loop, but not printing ' '</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Although this solves the issue of making sure print() can be called with a StaticArray<char, 14="">, it brings up another problem: <strong>using full template specialization means we have to explicitly define the length of the array this function will accept!</strong> Consider the following example:</char,></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StaticArray&lt;<span class="keyword">char</span>, <span class="number">12</span>&gt; char12;</span><br><span class="line">strcpy_s(char12.getArray(), <span class="number">12</span>, <span class="string">"Hello, mom!"</span>);</span><br><span class="line">print(char12);</span><br></pre></td></tr></table></figure>
<p>Calling print() with <char, 12=""> will call the version of print() that takes a StaticArray<t, size="">, because <char, 12=""> is of type StaticArray<char, 12="">, and our overloaded print() will only be called when passed a StaticArray<char, 14="">.</char,></char,></char,></t,></char,></p>
<p>Although we could make a copy of print() that handles StaticArray<char, 12="">, what happens when we want to call print() with an array size of 5, or 22? We‚Äôd have to copy the function for each different array size. That‚Äôs redundant.</char,></p>
<p>Obviously full template specialization is <code>too restrictive</code> a solution here. The solution we are looking for is partial template specialization.</p>
<p><strong>Partial template specialization</strong></p>
<p>Partial template specialization allows us to <code>specialize classes</code> (but not individual functions!) where some, but not all, of the template parameters have been explicitly defined. For our challenge above, the ideal solution would be to have our overloaded print function work with StaticArray of type char, but leave the length expression parameter templated so it can vary as needed. Partial template specialization allows us to do just that!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;<span class="keyword">char</span>, size&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; size; ++count)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As you can see here, we‚Äôve explicitly declared that this function will only work for StaticArray of type char, but size is still a templated expression parameter, so it will work for char arrays of any size. That‚Äôs all there is to it!</p>
<p><strong>Again</strong>, print is not a member function here.</p>
<p>Note that as of C++14, partial template specialization can only be used with classes, not template functions (functions must be fully specialized). Our void print(StaticArray<char, size=""> &amp;array) example works because the print function is not partially specialized (it‚Äôs just an overloaded function using a class parameter that‚Äôs partially specialized).</char,></p>
<p>Here‚Äôs a full program:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T m_array[size];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">T* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line">  T&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> m_array[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> size&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;T, size&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// for-loop (' ')</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;&gt; this is fully specialized template</span></span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line"><span class="comment">void print(StaticArray&lt;char, 14&gt; &amp;array) &#123;</span></span><br><span class="line"><span class="comment">  // for-loop (no ' ')</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overloaded of print() function for partially specialized StaticArray&lt;char, size&gt;</span></span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt; <span class="comment">// we just specialize T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;<span class="keyword">char</span>, size&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// for-loop (no ' ')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Partial template specialization for member functions</strong></p>
<p>The limitation on the partial specialization of functions can lead to some challenges when dealing with <code>member functions</code>. For example, what if we had defined StaticArray like this?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_array[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Partially specialize print():</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Doesn't work</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt;</span><br><span class="line"><span class="keyword">void</span> StaticArray&lt;<span class="keyword">double</span>, size&gt;::print() &#123;</span><br><span class="line">  <span class="comment">// for-loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>So how do we get around this? One obvious way is to partially specialize the entire class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span>&lt;double, size&gt; &#123;</span></span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>While it works, this isn‚Äôt a great solution, because we had to duplicate a lot of code from StaticArray<t, size=""> to StaticArray<double, size="">.</double,></t,></p>
<p>If only there were some way to reuse the code in StaticArray<t, size=""> in StaticArray<double, size="">. Sounds like a job for inheritance!</double,></t,></p>
<p>You might start off trying to write that code like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt; <span class="comment">// size is the expression parameter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span>&lt;double, size&gt;:</span> <span class="keyword">public</span> StaticArray&lt; <span class="comment">// Then what?</span></span><br><span class="line"><span class="comment">// But we can't reference StaticArray</span></span><br></pre></td></tr></table></figure>
<p>Fortunately, there‚Äôs a <code>workaround</code>, by using a common base class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray_Base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  T m_array[size];</span><br><span class="line">  <span class="comment">// foo</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span> :</span> <span class="keyword">public</span> StaticArray_Base&lt;T, size&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  StaticArray() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span>&lt;double, size&gt; :</span> <span class="keyword">public</span> StaticArray_Base&lt;<span class="keyword">double</span>, size&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">    <span class="comment">// foo</span></span><br><span class="line">    <span class="comment">// this-&gt;m_array, the prefix "this-&gt;" is needed</span></span><br><span class="line">    <span class="comment">// This is because the template parent of a template class is not instantiated during the compilation pass that first examines the template.</span></span><br><span class="line">    <span class="comment">// These names appear to be non-dependent on the particular template instantiation, and therefore the definitions need to be available. (If you never look at the definition of arrayListType, then reading the code of unorderedArrayListType it would appear the list and length need to be some sort of globals.)</span></span><br><span class="line">    <span class="comment">// One way, using this-&gt; before all the inherited names: this-&gt;list, this-&gt;length.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This prints the same as above, but has significantly less duplicated code.</p>
<h3 id="Partial-template-specialization-for-pointers"><a href="#Partial-template-specialization-for-pointers" class="headerlink" title="Partial template specialization for pointers"></a>Partial template specialization for pointers</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Storage(T value) &#123;</span><br><span class="line">    m_value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Storage() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>We showed that this class had problems when template parameter T was of type <code>char*</code> because of the shallow copy/pointer assignment that takes place in the constructor. In that lesson, we used full template specialization to create a specialized version of the Storage constructor for type char<em> that allocated memory and created an actual deep copy of m_value. For reference, here‚Äôs the fully specialized char</em> Storage constructor and destructor:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// fully specialized</span></span><br><span class="line">Storage&lt;<span class="keyword">char</span> *&gt;::Storage(<span class="keyword">char</span>* value) &#123;</span><br><span class="line">  <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (value[length] != <span class="string">'\0'</span>)</span><br><span class="line">    ++length;</span><br><span class="line">  ++length; <span class="comment">// +1 to account for null terminator</span></span><br><span class="line">  </span><br><span class="line">  m_value = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">    m_value[count] = value[count];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// fully specialized</span></span><br><span class="line">Storage&lt;<span class="keyword">char</span> *&gt;::~Storage() &#123;</span><br><span class="line">	<span class="keyword">delete</span>[] m_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>While that worked great for Storage<char*>, what about other pointer types (such as int*)? It‚Äôs fairly easy to see that if T is any pointer type, then we run into the problem of the constructor doing a pointer assignment instead of making an actual deep copy of the element being pointed to.</char*></p>
<p>Because full template specialization forces us to fully resolve templated types, in order to fix this issue we‚Äôd have to define a new specialized constructor (and destructor) for each and every pointer type we wanted to use Storage with! This leads to lots of duplicate code, which as you well know by now is something we want to avoid as much as possible.</p>
<p>Fortunately, partial template specialization offers us a convenient solution. In this case, we‚Äôll use <code>class partial template specialization</code> to define a special version of the Storage class that works for pointer values. This class is considered partially specialized because we‚Äôre telling the compiler that it‚Äôs only for use with pointer types, even though we haven‚Äôt specified the underlying type exactly.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>&lt;T*&gt; &#123;</span>  <span class="comment">// this is a partial-specialization of Storage that works with pointer types</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Storage(T* value) &#123;  <span class="comment">// for pointer btype T</span></span><br><span class="line">    <span class="comment">// For pointers, we'll do a deep copy</span></span><br><span class="line">    m_value = <span class="keyword">new</span> T(*value);  <span class="comment">// this copies a single value, not an array</span></span><br><span class="line">  &#125;</span><br><span class="line">  ~Storage() &#123;</span><br><span class="line">    <span class="keyword">delete</span> m_value;   <span class="comment">// so we use scalar delete here, not array delete</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *m_value &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">7</span>;</span><br><span class="line">Storage&lt;<span class="keyword">int</span> *&gt; myintptr(&amp;x);</span><br><span class="line">myintptr.print();</span><br></pre></td></tr></table></figure>
<p>When myintptr is defined with an int* template parameter, the compiler sees that we have defined a partially specialized template class that works with any pointer type, and instantiates a version of Storage using that template.</p>
<p>It‚Äôs worth noting that because this partially specialized Storage class only allocates a single value, for C-style strings, only the first character will be copied. If the desire is to copy entire strings, a specialization of the constructor (and destructor) for type char<em> can be fully specialized. <code>The fully specialized version will take precedence over the partially specialized version</code>. Here‚Äôs an example program that uses both partial specialization for pointers, and full specialization for char</em>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Storage(T value) &#123;</span><br><span class="line">    m_value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Storage() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial-specialization of Storage class for pointers</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage</span>&lt;T*&gt; &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Storage(T* value) &#123;</span><br><span class="line">    m_value = <span class="keyword">new</span> T(*value);</span><br><span class="line">  &#125;</span><br><span class="line">  ~Storage() &#123;</span><br><span class="line">    <span class="keyword">delete</span> m_value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *m_value &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------ Full specialization for type char * ----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Full specialization of constructor for type char *</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span> *&gt;::Storage(<span class="keyword">char</span> *value) &#123;</span><br><span class="line">  <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (value[length] != <span class="string">'\0'</span>)</span><br><span class="line">    ++length;</span><br><span class="line">  ++length;</span><br><span class="line">  m_value = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">    m_value[count] = value[count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Full specialization of destructor for type char *</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span>*&gt;::~Storage() &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] m_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Full specialization of print function for type char *</span></span><br><span class="line"><span class="comment">// Without this, printing a Storage&lt;char*&gt; would call Storage&lt;T*&gt;::print(), which only prints the first elemetn</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Storage&lt;<span class="keyword">char</span>*&gt;::print() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Storage&lt;<span class="keyword">int</span>&gt; myint(<span class="number">5</span>);</span><br><span class="line">  myint.print();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">7</span>;</span><br><span class="line">  Storage&lt;<span class="keyword">int</span> *&gt; myintptr(&amp;x);</span><br><span class="line"></span><br><span class="line">  x = <span class="number">9</span>;</span><br><span class="line">  myintptr.print();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">40</span>]&#123; <span class="string">"Alex"</span> &#125;; <span class="comment">// requires C++14</span></span><br><span class="line">  <span class="comment">// otherwise, use:</span></span><br><span class="line">  <span class="comment">// char *name = new char[40];</span></span><br><span class="line">  <span class="comment">// strcpy(name, "Alex");</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Store the name</span></span><br><span class="line">  Storage&lt;<span class="keyword">char</span> *&gt; myname(name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] name;</span><br><span class="line"></span><br><span class="line">  myname.print();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using partial template class specialization to create separate pointer and non-pointer implementations of a class is extremely useful when you want a class to handle both differently, but in a way that‚Äôs completely transparent to the end-user.</p>

        
      </div>
      
      
      
    </div>
    
    
    
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/cat_with_glasses.jpg" alt="Junhao Wang">
            
              <p class="site-author-name" itemprop="name">Junhao Wang</p>
              <p class="site-description motion-element" itemprop="description">Debug the old world, bug the new world!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">117</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/chuckwangg" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i>Facebook</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/junhaowww" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.linkedin.com/in/junhaowww/" target="_blank" title="LinkedIn">
                      
                        <i class="fa fa-fw fa-linkedin"></i>LinkedIn</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/maodai/" target="_blank" title="Ë±ÜÁì£ (Book)">
                      
                        <i class="fa fa-fw fa-book"></i>Ë±ÜÁì£ (Book)</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.jianshu.com/u/41865efdad5d/" title="Xiaofud" target="_blank">Xiaofud</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.davex.pw/" title="DaveX" target="_blank">DaveX</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://alexfan.xyz/" title="alexfan.xyz" target="_blank">alexfan.xyz</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-Functions"><span class="nav-number">1.</span> <span class="nav-text">Virtual Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pointers-and-references-to-the-base-class-of-derived-objects"><span class="nav-number">1.1.</span> <span class="nav-text">Pointers and references to the base class of derived objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Virtual-functions-and-polymorphism"><span class="nav-number">1.2.</span> <span class="nav-text">Virtual functions and polymorphism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-override-and-final-specifiers-and-covariant-return-types"><span class="nav-number">1.3.</span> <span class="nav-text">The override and final specifiers, and covariant return types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Virtual-destructors-virtual-assignment-and-overriding-virtualization"><span class="nav-number">1.4.</span> <span class="nav-text">Virtual destructors, virtual assignment, and overriding virtualization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Early-binding-and-late-binding"><span class="nav-number">1.5.</span> <span class="nav-text">Early binding and late binding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-virtual-table"><span class="nav-number">1.6.</span> <span class="nav-text">The virtual table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pure-virtual-functions-abstract-base-classes-and-interface-classes"><span class="nav-number">1.7.</span> <span class="nav-text">Pure virtual functions, abstract base classes, and interface classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Virtual-base-classes"><span class="nav-number">1.8.</span> <span class="nav-text">Virtual base classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-slicing"><span class="nav-number">1.9.</span> <span class="nav-text">Object slicing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dynamic-casting-downcasting"><span class="nav-number">1.10.</span> <span class="nav-text">Dynamic casting (downcasting)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Printing-inherited-classes-using-operator-lt-lt"><span class="nav-number">1.11.</span> <span class="nav-text">Printing inherited classes using operator&lt;&lt;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Templates"><span class="nav-number">2.</span> <span class="nav-text">Templates</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-templates"><span class="nav-number">2.1.</span> <span class="nav-text">Function templates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-template-instances"><span class="nav-number">2.2.</span> <span class="nav-text">Function template instances</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Template-classes"><span class="nav-number">2.3.</span> <span class="nav-text">Template classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Non-type-parameters"><span class="nav-number">2.4.</span> <span class="nav-text">Non-type parameters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-template-specialization"><span class="nav-number">2.5.</span> <span class="nav-text">Function template specialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-template-specialization"><span class="nav-number">2.6.</span> <span class="nav-text">Class template specialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Partial-template-specialization"><span class="nav-number">2.7.</span> <span class="nav-text">Partial template specialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Partial-template-specialization-for-pointers"><span class="nav-number">2.8.</span> <span class="nav-text">Partial template specialization for pointers</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junhao Wang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://junhaow.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.junhaow.com/studynotes/cpp/learncpp/Study Notes on LearnCpp Part 5.html';
          this.page.identifier = 'studynotes/cpp/learncpp/Study Notes on LearnCpp Part 5.html';
          this.page.title = 'Study Notes on LearnCpp (Part 5 - Virtual Functions, Templates)';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://junhaow.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  

  
  


  

  


</body>
</html>
